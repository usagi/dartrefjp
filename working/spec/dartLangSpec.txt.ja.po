# Dart Language Spec (en-->ja)
# Copyright (C) 2012 dartrefjp
# This file is distributed under the same license as the dartrefjp package.
# Usagi Ito <usagi@WonderRabbitProject.net>, 2012.
#
msgid ""
msgstr ""
"Project-Id-Version: dartrefjp Thu, 08 Mar 2012 06:38:47 +0900\n"
"Report-Msgid-Bugs-To: usagi@WonderRabbitProject.net\n"
"POT-Creation-Date: 2012-03-08 06:39+0900\n"
"PO-Revision-Date: 2012-03-23 22:39+0900\n"
"Last-Translator: yutopp <yutopp@gmail.com>\n"
"Language-Team: dartrefjp <dartrefjp@googlegroups.com>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: dartLangSpec.txt:4
msgid "Dart Programming Language Specification"
msgstr "Dart プログラミング言語仕様"

#. type: Plain text
#: dartLangSpec.txt:6
msgid "Draft Version 0.07"
msgstr "Draft Version 0.07"

#. type: Plain text
#: dartLangSpec.txt:9
msgid "The Dart Team January 20, 2012"
msgstr ""
"The Dart Team 2012年1月20日\n"
"dartrefjp 2012年3月"

#. type: Plain text
#: dartLangSpec.txt:12
msgid "Contents 1 Notes 5"
msgstr "Contents 1 Notes 5"

#. type: Plain text
#: dartLangSpec.txt:15
msgid "1.1 Licensing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.2 Change Log . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5"
msgstr ""
"1.1 ライセンス . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 \n"
"1.2 更新履歴 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5"

#. type: Plain text
#: dartLangSpec.txt:21
msgid "1.2.1 Changes Since Version 0.02 . . . . . . . . . . . . . . . . . 5 1.2.2 Changes Since Version 0.03 . . . . . . . . . . . . . . . . . 5 1.2.3 Changes Since Version 0.04 . . . . . . . . . . . . . . . . . 6 1.2.4 Changes Since Version 0.05 . . . . . . . . . . . . . . . . . 6 1.2.5 Changes Since Version 0.06 . . . . . . . . . . . . . . . . . 6"
msgstr ""
"1.2.1 Version 0.02 からの変更点 . . . . . . . . . . . . . . . . . 5 \n"
"1.2.2 Version 0.03 からの変更点 . . . . . . . . . . . . . . . . . 5 \n"
"1.2.3 Version 0.04 からの変更点 . . . . . . . . . . . . . . . . . 6 \n"
"1.2.4 Version 0.05 からの変更点 . . . . . . . . . . . . . . . . . 6 \n"
"1.2.5 Version 0.06 からの変更点 . . . . . . . . . . . . . . . . . 6"

#. type: Plain text
#: dartLangSpec.txt:24
msgid "2 Notation 7 3 Overview 9"
msgstr ""
"2 記法 7 \n"
"3 概要 9"

#. type: Plain text
#: dartLangSpec.txt:28
msgid "3.1 Scoping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 3.2 Privacy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 3.3 Concurrency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10"
msgstr ""
"3.1 スコープ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 \n"
"3.2 プライバシー . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 \n"
"3.3 並行性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10"

#. type: Plain text
#: dartLangSpec.txt:32
msgid "4 Errors and Warnings 10 5 Variables 11 6 Functions 12"
msgstr ""
"4 警告とエラー 10 \n"
"5 変数 11 \n"
"6 関数 12"

#. type: Plain text
#: dartLangSpec.txt:35
msgid "6.1 Function Declarations . . . . . . . . . . . . . . . . . . . . . . . . 13 6.2 Formal Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . 14"
msgstr ""
"6.1 関数の宣言 . . . . . . . . . . . . . . . . . . . . . . . . 13 \n"
"6.2 仮引数 . . . . . . . . . . . . . . . . . . . . . . . . . . 14"

#. type: Plain text
#: dartLangSpec.txt:39
msgid "6.2.1 Positional Formals . . . . . . . . . . . . . . . . . . . . . . 14 6.2.2 Named Optional Formals . . . . . . . . . . . . . . . . . . 15 6.3 Type of a Function . . . . . . . . . . . . . . . . . . . . . . . . . . 15"
msgstr ""
"6.2.1 固定仮引数 . . . . . . . . . . . . . . . . . . . . . . 14 \n"
"6.2.2 名前付きオプショナル仮引数 . . . . . . . . . . . . . . . . . . 15 \n"
"6.3 関数の型 . . . . . . . . . . . . . . . . . . . . . . . . . . 15"

#. type: Plain text
#: dartLangSpec.txt:41
msgid "7 Classes 15"
msgstr "7 クラス 15"

#. type: Plain text
#: dartLangSpec.txt:43
msgid "7.1 Instance Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . 17"
msgstr "7.1 インスタンス メソッド . . . . . . . . . . . . . . . . . . . . . . . . . . . 17"

#. type: Plain text
#: dartLangSpec.txt:46
msgid "7.1.1 Abstract Methods . . . . . . . . . . . . . . . . . . . . . . 17 7.1.2 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 18"
msgstr ""
"7.1.1 抽象メソッド . . . . . . . . . . . . . . . . . . . . . . 17 \n"
"7.1.2 演算子 . . . . . . . . . . . . . . . . . . . . . . . . . . . 18"

#. type: Plain text
#: dartLangSpec.txt:48
msgid "1\f"
msgstr "1\f"

#. type: Plain text
#: dartLangSpec.txt:53
msgid "7.2 Getters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 7.3 Setters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 7.4 Instance Variables . . . . . . . . . . . . . . . . . . . . . . . . . . 20 7.5 Constructors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21"
msgstr ""
"7.2 取得メソッド . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 \n"
"7.3 設定メソッド . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 \n"
"7.4 インスタンス変数 . . . . . . . . . . . . . . . . . . . . . . . . . . 20 \n"
"7.5 コンストラクタ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21"

#. type: Plain text
#: dartLangSpec.txt:60
msgid "7.5.1 Generative Constructors . . . . . . . . . . . . . . . . . . . 21 7.5.2 Factories . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 7.5.3 Constant Constructors . . . . . . . . . . . . . . . . . . . . 25 7.6 Static Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 7.7 Static Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 7.8 Superclasses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28"
msgstr ""
"7.5.1 生成的コンストラクタ . . . . . . . . . . . . . . . . . . . 21 \n"
"7.5.2 ファクトリ . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 \n"
"7.5.3 定数コンストラクタ . . . . . . . . . . . . . . . . . . . . 25 \n"
"7.6 静的メソッド . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 \n"
"7.7 静的変数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 \n"
"7.8 スーパークラス . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28"

#. type: Plain text
#: dartLangSpec.txt:63
msgid "7.8.1 Inheritance and Overriding . . . . . . . . . . . . . . . . . 28 7.9 Superinterfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29"
msgstr ""
"7.8.1 継承とオーバーライド . . . . . . . . . . . . . . . . . 28 \n"
"7.9 スーパーインターフェース . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29"

#. type: Plain text
#: dartLangSpec.txt:65
msgid "8 Interfaces 29"
msgstr "8 インターフェース 29"

#. type: Plain text
#: dartLangSpec.txt:67
msgid "8.1 Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30"
msgstr "8.1 メソッド. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30"

#. type: Plain text
#: dartLangSpec.txt:72
msgid "8.1.1 Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 8.2 Getters and Setters . . . . . . . . . . . . . . . . . . . . . . . . . . 30 8.3 Factories and Constructors . . . . . . . . . . . . . . . . . . . . . 30 8.4 Superinterfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31"
msgstr ""
"8.1.1 演算子 . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 \n"
"8.2 取得メソッドと設定メソッド . . . . . . . . . . . . . . . . . . . . . . . . . . 30 \n"
"8.3 ファクトリとコンストラクタ . . . . . . . . . . . . . . . . . . . . . 30 \n"
"8.4 スーパーインターフェース . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31"

#. type: Plain text
#: dartLangSpec.txt:74
msgid "8.4.1 Inheritance and Overriding . . . . . . . . . . . . . . . . . 32"
msgstr "8.4.1 継承とオーバーロード . . . . . . . . . . . . . . . . . 32"

#. type: Plain text
#: dartLangSpec.txt:77
msgid "9 Generics 33 10 Expressions 33"
msgstr ""
"9 ジェネリクス 33 \n"
"10 式 33"

#. type: Plain text
#: dartLangSpec.txt:82
msgid "10.1 Constants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 10.2 Null . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 10.3 Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 10.4 Booleans . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37"
msgstr ""
"10.1 定数 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34 \n"
"10.2 Null . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 \n"
"10.3 数値 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36 \n"
"10.4 ブール値 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37"

#. type: Plain text
#: dartLangSpec.txt:85
msgid "10.4.1 Boolean Conversion . . . . . . . . . . . . . . . . . . . . . 37 10.5 Strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38"
msgstr ""
"10.4.1 ブール値変換 . . . . . . . . . . . . . . . . . . . . . 37 \n"
"10.5 文字列 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38"

#. type: Plain text
#: dartLangSpec.txt:92
msgid "10.5.1 String Interpolation . . . . . . . . . . . . . . . . . . . . . 40 10.6 Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 10.7 Maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 10.8 Function Expressions . . . . . . . . . . . . . . . . . . . . . . . . . 44 10.9 This . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 10.10 Instance Creation . . . . . . . . . . . . . . . . . . . . . . . . . . 45"
msgstr ""
"10.5.1 文字列内挿 . . . . . . . . . . . . . . . . . . . . . 40 \n"
"10.6 リスト . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41 \n"
"10.7 マップ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42 \n"
"10.8 関数式 . . . . . . . . . . . . . . . . . . . . . . . . . 44 \n"
"10.9 This . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44 \n"
"10.10 インスタンスの生成 . . . . . . . . . . . . . . . . . . . . . . . . . . 45"

#. type: Plain text
#: dartLangSpec.txt:98
msgid "10.10.1 New . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 10.10.2 Const . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 10.11 Spawning an Isolate . . . . . . . . . . . . . . . . . . . . . . . . . 48 10.12 Property Extraction . . . . . . . . . . . . . . . . . . . . . . . . . 49 10.13 Function Invocation . . . . . . . . . . . . . . . . . . . . . . . . . 49"
msgstr ""
"10.10.1 New . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 \n"
"10.10.2 Const . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 \n"
"10.11 Isolateの生成 . . . . . . . . . . . . . . . . . . . . . . . . . 48 \n"
"10.12 プロパティの展開 . . . . . . . . . . . . . . . . . . . . . . . . . 49 \n"
"10.13 関数呼び出し . . . . . . . . . . . . . . . . . . . . . . . . . 49"

#. type: Plain text
#: dartLangSpec.txt:104
msgid "10.13.1 Actual Argument List Evaluation . . . . . . . . . . . . . 49 10.13.2 Binding Actuals to Formals . . . . . . . . . . . . . . . . . 50 10.13.3 Unqualified Invocation . . . . . . . . . . . . . . . . . . . 50 10.13.4 Function Expression Invocation . . . . . . . . . . . . . . 51 10.14 Method Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . 51"
msgstr ""
"10.13.1 実引数リスト評価 . . . . . . . . . . . . . 49 \n"
"10.13.2 実引数の仮引数への束縛 . . . . . . . . . . . . . . . . . 50 \n"
"10.13.3 無修飾呼び出し . . . . . . . . . . . . . . . . . . . 50 \n"
"10.13.4 関数式呼び出し . . . . . . . . . . . . . . 51 \n"
"10.14 メソッド呼び出し . . . . . . . . . . . . . . . . . . . . . . . . . . 51"

#. type: Plain text
#: dartLangSpec.txt:106
msgid "2\f"
msgstr "2\f"

#. type: Plain text
#: dartLangSpec.txt:113
msgid "10.14.1 Ordinary Invocation . . . . . . . . . . . . . . . . . . . . . 51 10.14.2 Static Invocation . . . . . . . . . . . . . . . . . . . . . . . 52 10.14.3 Super Invocation . . . . . . . . . . . . . . . . . . . . . . . 53 10.14.4 Sending Messages . . . . . . . . . . . . . . . . . . . . . . . 54 10.15 Getter Invocation . . . . . . . . . . . . . . . . . . . . . . . . . . 54 10.16 Assignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55"
msgstr ""
"10.14.1 通常呼び出し . . . . . . . . . . . . . . . . . . . . . 51 \n"
"10.14.2 静的呼び出し . . . . . . . . . . . . . . . . . . . . . . . 52 \n"
"10.14.3 Superの呼び出し . . . . . . . . . . . . . . . . . . . . . . . 53 \n"
"10.14.4 メッセージの送信 . . . . . . . . . . . . . . . . . . . . . . . 54 \n"
"10.15 取得メソッド呼び出し . . . . . . . . . . . . . . . . . . . . . . . . . . 54 \n"
"10.16 代入 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55"

#. type: Plain text
#: dartLangSpec.txt:128
msgid "10.16.1 Compound Assignment . . . . . . . . . . . . . . . . . . . 56 10.17 Conditional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 10.18 Logical Boolean Expressions . . . . . . . . . . . . . . . . . . . . 57 10.19 Bitwise Expressions . . . . . . . . . . . . . . . . . . . . . . . . . 57 10.20 Equality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 10.21 Relational Expressions . . . . . . . . . . . . . . . . . . . . . . . 59 10.22 Shift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 10.23 Additive Expressions . . . . . . . . . . . . . . . . . . . . . . . . 60 10.24 Multiplicative Expressions . . . . . . . . . . . . . . . . . . . . . 60 10.25 Unary Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . 61 10.26 Postfix Expressions . . . . . . . . . . . . . . . . . . . . . . . . . 62 10.27 Assignable Expressions . . . . . . . . . . . . . . . . . . . . . . . 63 10.28 Identifier Reference . . . . . . . . . . . . . . . . . . . . . . . . . 63 10.29 Type Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66"
msgstr ""
"10.16.1 複合代入 . . . . . . . . . . . . . . . . . . . 56 \n"
"10.17 条件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56 \n"
"10.18 論理ブール式 . . . . . . . . . . . . . . . . . . . . 57 \n"
"10.19 ビット式 . . . . . . . . . . . . . . . . . . . . . . . . . 57 \n"
"10.20 等式 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 \n"
"10.21 関係式 . . . . . . . . . . . . . . . . . . . . . . . 59 \n"
"10.22 シフト . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59 \n"
"10.23 加減式 . . . . . . . . . . . . . . . . . . . . . . . . 60 \n"
"10.24 乗除式 . . . . . . . . . . . . . . . . . . . . . 60 \n"
"10.25 単項式 . . . . . . . . . . . . . . . . . . . . . . . . . . 61 \n"
"10.26 後置式 . . . . . . . . . . . . . . . . . . . . . . . . . 62 \n"
"10.27 代入可能式 . . . . . . . . . . . . . . . . . . . . . . . 63 \n"
"10.28 識別子参照 . . . . . . . . . . . . . . . . . . . . . . . . . 63 \n"
"10.29 型テスト . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66"

#. type: Plain text
#: dartLangSpec.txt:130
msgid "11 Statements 66"
msgstr "11 文 66"

#. type: Plain text
#: dartLangSpec.txt:136
msgid "11.1 Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 11.2 Expression Statements . . . . . . . . . . . . . . . . . . . . . . . . 67 11.3 Variable Declaration . . . . . . . . . . . . . . . . . . . . . . . . . 67 11.4 If . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 11.5 For . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68"
msgstr ""
"11.1 ブロック . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67 \n"
"11.2 式文 . . . . . . . . . . . . . . . . . . . . . . . . 67 \n"
"11.3 変数宣言 . . . . . . . . . . . . . . . . . . . . . . . . . 67 \n"
"11.4 If . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68 \n"
"11.5 For . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68"

#. type: Plain text
#: dartLangSpec.txt:149
msgid "11.5.1 For Loop . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 11.5.2 Foreach . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 11.6 While . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 11.7 Do . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 11.8 Switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 11.9 Try . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 11.10 Return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 11.11 Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 11.12 Break . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 11.13 Continue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 11.14 Throw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 11.15 Assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76"
msgstr ""
"11.5.1 Forループ . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 \n"
"11.5.2 Foreach . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 \n"
"11.6 While . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 \n"
"11.7 Do . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 \n"
"11.8 Switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 \n"
"11.9 Try . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71 \n"
"11.10 Return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73 \n"
"11.11 ラベル . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74 \n"
"11.12 Break . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 \n"
"11.13 Continue . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 \n"
"11.14 Throw . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 \n"
"11.15 Assert . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76"

#. type: Plain text
#: dartLangSpec.txt:151
msgid "12 Libraries and Scripts 77"
msgstr "12 ライブラリとスクリプト 77"

#. type: Plain text
#: dartLangSpec.txt:155
msgid "12.1 Imports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 12.2 Includes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 12.3 Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80"
msgstr ""
"12.1 Imports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 \n"
"12.2 Includes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79 \n"
"12.3 Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80"

#. type: Plain text
#: dartLangSpec.txt:157
msgid "3\f"
msgstr "3\f"

#. type: Plain text
#: dartLangSpec.txt:159
msgid "13 Types 80"
msgstr "13 型 80"

#. type: Plain text
#: dartLangSpec.txt:163
msgid "13.1 Static Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 13.2 Dynamic Type System . . . . . . . . . . . . . . . . . . . . . . . . 81 13.3 Type Declarations . . . . . . . . . . . . . . . . . . . . . . . . . . 83"
msgstr ""
"13.1 静的型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 \n"
"13.2 動的型システム . . . . . . . . . . . . . . . . . . . . . . . . 81 \n"
"13.3 型宣言 . . . . . . . . . . . . . . . . . . . . . . . . . . 83"

#. type: Plain text
#: dartLangSpec.txt:170
msgid "13.3.1 Typedef . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 13.4 Interface Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 13.5 Function Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 13.6 Type Dynamic . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 13.7 Type Void . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 13.8 Parameterized Types . . . . . . . . . . . . . . . . . . . . . . . . . 86"
msgstr ""
"13.3.1 Typedef . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 \n"
"13.4 インターフェース型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83 \n"
"13.5 関数型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84 \n"
"13.6 Dynamic型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85 \n"
"13.7 Void型 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86 \n"
"13.8 パラメータ化された型 . . . . . . . . . . . . . . . . . . . . . . . . . 86"

#. type: Plain text
#: dartLangSpec.txt:173
msgid "13.8.1 Actual Type of Declaration . . . . . . . . . . . . . . . . . 86 13.8.2 Least Upper Bounds . . . . . . . . . . . . . . . . . . . . . 87"
msgstr ""
"13.8.1 宣言の実際の型 . . . . . . . . . . . . . . . . . 86 \n"
"13.8.2 上限 . . . . . . . . . . . . . . . . . . . . . 87"

#. type: Plain text
#: dartLangSpec.txt:175
msgid "14 Reference 87"
msgstr "14 リファレンス 87"

#. type: Plain text
#: dartLangSpec.txt:177
msgid "14.1 Lexical Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87"
msgstr "14.1 構文規則 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87"

#. type: Plain text
#: dartLangSpec.txt:181
msgid "14.1.1 Reserved Words . . . . . . . . . . . . . . . . . . . . . . . 87 14.1.2 Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 14.2 Operator Precedence . . . . . . . . . . . . . . . . . . . . . . . . . 88"
msgstr ""
"14.1.1 予約語 . . . . . . . . . . . . . . . . . . . . . . . 87 \n"
"14.1.2 コメント . . . . . . . . . . . . . . . . . . . . . . . . . . . 87 \n"
"14.2 演算子の優先順位 . . . . . . . . . . . . . . . . . . . . . . . . . 88"

#. type: Plain text
#: dartLangSpec.txt:183
msgid "4\f"
msgstr "4\f"

#. type: Plain text
#: dartLangSpec.txt:188
msgid "Draft Dart Programming Language Specification Draft 5 1 Notes This is a work in progress. Expect the contents and language rules to change over time. Please mail comments to gbracha@google.com."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:192
msgid "1.1 Licensing Except as otherwise noted at http://code.google.com/policies.html#restrictions, the content of this document is licensed under the Creative Commons Attribution 3.0 License available at:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:196
msgid "http://creativecommons.org/licenses/by/3.0/ and code samples are licensed under the BSD license available at http://code.google.com/google bsd license.html."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:202
msgid "1.2 Change Log 1.2.1 Changes Since Version 0.02 The following changes have been made in version 0.03 since version 0.02. In addition, various typographical errors have been corrected. The changes are listed by section number."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:205
msgid "2: Expanded examples of grammar.  7.5.2: Corrected reference to undefined production typeVariables to typeParameters."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:207
msgid "7.9: Removed static warning when imported superinterface of a class contains private members."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:211
msgid "8.3: Removed redundant prohibition on default values.  8.4: Removed static warning when imported superinterface of an interface contains private members."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:214
msgid "10: Fixed typo in grammar.  10.10.1, 10.10.2 : made explicit accessibility requirement for class being constructed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:218
msgid "10.10.2: make clear that referenced constructor must be marked const.  10.14.3: fixed botched sentence where superclass S is introduced.  10.26: qualified definition of v + + so it is clear that v is an identifier."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:223
msgid "1.2.2 Changes Since Version 0.03 7.1, 8.1: Added missing requirement that overriding methods have same number of required parameters and all optional parameters as overridden method, in same order."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:226
msgid "9: Added prohibition against cyclic type hierarchy for type parameters.  10.10: Clarified requirements on use of parameterized types in instance creation expressions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:228
msgid "10.13.2: Added requirement that qi are distinct.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:230
msgid "Draft Dart Programming Language Specification Draft 6"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:232
msgid "10.14.2. Static method invocation determines the function (which may involve evaluating a getter) before evaluating the arguments, so that static invocation and top-level function invocation agree."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:235
msgid "10.29: Added missing test that type being tested against is in scope and is indeed a type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:239
msgid "11.5.1: Changed for loop to introduce fresh variable for each iteration.  13.8: Malformed parameterized types generate warnings, not errors(except when used in reified contexts like instance creation and superclasses/interfaces)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:242
msgid "1.2.3 Changes Since Version 0.04 Added hyperlinks in PDF."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:245
msgid "7.1.2: Removed unary plus operator. Clarified that operator formals must be required."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:252
msgid "7.5.3: Filled in a lot of missing detail.  8.3: Allowed factory class to be declared via a qualified name.  10.3: Changed production for N umber.  10.10.2: Added requirements that actuals be constant, rules for dealing with inappropriate types of actuals, and examples. Also explicitly prohibit type variables."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:255
msgid "10.13.4: Modified final bullet to keep it inline with similar clauses in other sections. Exact wording of these sections also tweaked slightly."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:258
msgid "10.25: Specified ! operator. Eliminated section on prefix expressions and moved contents to section on unary expressions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:260
msgid "14.1: Specified unicode form of Dart source."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:263
msgid "1.2.4 Changes Since Version 0.05 7.5.1: Clarified how initializing formals can act as optional parameters of generative constructors."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:266
msgid "7.5.2: Treat factories as constructors, so type parameters are implicitly in scope."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:269
msgid "8.3: Simplify rules for interface factory clauses. Use the keyword default instead of factory."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:273
msgid "9: Mention that typedefs can have type parameters.  10.29: Added checked mode test that type arguments match generic type.  13.2: Added definition of malformed types, and requirement on their handling in checked mode."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:276
msgid "1.2.5 Changes Since Version 0.06 5: Top level variable initializers must be constant."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:280
msgid "7: Added abstract modifier to grammar.  7, 7.6, 7.7, 10.13.3,10.28: Superclass static members are not in scope in subclasses, and do not conflict with subclass members.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:282
msgid "Draft Dart Programming Language Specification Draft 7"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:285
msgid "7.1.2: []= must return void. Operator call added to support function emulation. Removed operator >>>. Made explicit restriction on methods named call or negate."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:288
msgid "10.1: Added !e as constant expression. Clarified what happens if evaluation of a constant fails."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:291
msgid "10.7: Map keys need not be constants. However, they are always string literals."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:295
msgid "10.9: State restrictions on use of this.  10.10, 10.10.1: Rules for bounds checking of constructor arguments when calling default constructors for interfaces refined."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:300
msgid "10.14.1: Revised semantics to account for function emulation.  10.14.2: Revised semantics to account for function emulation.  10.14.3: Factory constructors cannot contain super invocations. Revised semantics to account for function emulation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:305
msgid "10.16: Specified assignment involving []= operator.  10.16.1: Removed operator >>>.  10.22: Removed operator >>>.  10.26: Postfix -- operator specified. Behavior of postfix operations on subscripted expressions specified."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:308
msgid "10.28: Added built-in identifier call. Banned use of built-in identifiers as types made other uses warnings."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:311
msgid "10.29: Moved specification of test that type arguments match generic type to 13.2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:315
msgid "11.8: Corrected evaluation of case clauses so that case expression is the receiver of ==. Revised specification to correctly deal with blank statements in case clauses."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:319
msgid "11.15: Fixed bug in assert specification that could lead to puzzlers.  13.2: Consolidated definition of malformed types.  13.5: Revised semantics to account for function emulation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:324
msgid "2 Notation We distinguish between normative and non-normative text. Normative text defines the rules of Dart. It is given in this font. At this time, non-normative text includes:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:327
msgid "Rationale Discussion of the motivation for language design decisions appears in italics. Distinguishing normative from non-normative helps clarify what part of the text is binding and what part is merely expository."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:329
msgid "Commentary Comments such as \"The careful reader will have noticed that the name Dart"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:334
msgid "has four characters\" serve to illustrate or clarify the specification, but are redundant with the normative text. The difference between commentary and rationale can be subtle. Commentary is more general than rationale, and may include illustrative examples or clarifications.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:337
msgid "Draft Dart Programming Language Specification Draft 8 Open questions (in this font). Open questions are points that are unsettled in the mind"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:342
msgid "of the author(s) of the specification; expect them (the questions, not the authors; precision is important in a specification) to be eliminated in the final specification. Should the text at the end of the previous bullet be rationale or commentary?"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:353
msgid "Reserved words and built-in identifiers (10.28) appear in bold.  Examples would be, switch or class.  Grammar productions are given in a common variant of EBNF. The left hand side of a production ends with a colon. On the right hand side, alternation is represented by vertical bars, and sequencing by spacing. Optional elements of a production are suffixed by a question mark like so: anElephant?. Appending a star to an element of a production means it may be repeated zero or more times. Appending a plus sign to a production means it occurs one or more times.  Parentheses are used for grouping. Negation (the not combinator of PEGs) is represented by prefixing an element of a production with a tilde."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:355
msgid "An example would be:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:357
msgid "AProduction:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:368
msgid "AnAlternative | AnotherAlternative | OneThing After Another | ZeroOrMoreThings* | OneOrMoreThings+ | AnOptionalThing? | (Some Grouped Things) | ~NotAThing | A LEXICAL THING ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:374
msgid "Both syntactic and lexical productions are represented this way. Lexical productions are distinguished by their names. The names of lexical productions consist exclusively of upper case characters and underscores. As always, within grammatical productions, whitespace and comments between elements of the production are implicitly ignored unless stated otherwise."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:377
msgid "Productions are embedded, as much as possible, in the discussion of the constructs they represent."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:381
msgid "A list x1, . . . , xn denotes any list of n elements of the form xi, 1 <= i <= n.  Note that n may be zero, in which case the list is empty. We use such lists extensively throughout this specification."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:383
msgid "The notation [x1, . . . , xn/y1, . . . , yn]E denotes a copy of E in which all occurrences of yi, 1 <= i <= n have been replaced with xi."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:387
msgid "The specifications of operators often involve statements such as x op y is equivalent to the method invocation x.op(y). Such specifications should be understood as a shorthand for:\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:389
msgid "Draft Dart Programming Language Specification Draft 9"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:391
msgid "x op y is equivalent to the method invocation x.op0(y), assuming the class"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:394
msgid "of x actually declared a non-operator method named op0 defining the same function as the operator op."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:398
msgid "This circumlocution is required because x.op(y), where op is an operator, is not legal syntax. However, it is painfully verbose, and we prefer to state this rule once here, and use a concise and clear notation across the specification."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:401
msgid "When the specification refers to the order given in the program, it means the order of the program source code text, scanning left-to-right and top-to-bottom."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:404
msgid "3 Overview Dart is a class-based, single-inheritance, pure object-oriented programming language. Dart is optionally typed (13) and supports reified generics and interfaces."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:408
msgid "Dart programs may be statically checked. The static checker will report some violations of the type rules, but such violations do not abort compilation or preclude execution."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:413
msgid "Dart programs may be executed in one of two modes: production mode or checked mode. In production mode, static type annotations (13.1) have absolutely no effect on execution. In checked mode, assignments are dynamically checked, and certain violations of the type system raise exceptions at run time."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:415
msgid "The coexistence between optional typing and reification is based on the following:"
msgstr ""

#. type: Bullet: '1. '
#: dartLangSpec.txt:417
msgid "Reified type information reflects the types of objects at runtime and may"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:421
msgid "always be queried by dynamic typechecking constructs (the analogs of instanceOf, casts, typecase etc. in other languages). Reified type information includes class and interface declarations, the class of an object, and type arguments to constructors."
msgstr ""

#. type: Bullet: '2. '
#: dartLangSpec.txt:423
msgid "Static type annotations determine the types of variables and function declarations (including methods and constructors)."
msgstr ""

#. type: Bullet: '3. '
#: dartLangSpec.txt:425
msgid "Production mode respects optional typing. Static type annotations do not"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:427
msgid "affect runtime behavior."
msgstr ""

#. type: Bullet: '4. '
#: dartLangSpec.txt:429
msgid "Checked mode utilizes static type annotations and dynamic type information"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:431
msgid "aggressively yet selectively to provide early error detection during development."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:434
msgid "Dart programs are organized in a modular fashion into units called libraries (12). Libraries are units of encapsulation and may be mutually recursive."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:437
msgid "However they are not first class. To get multiple copies of a library running simultaneously, one needs to spawn an isolate."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:441
msgid "3.1 Scoping Dart is lexically scoped and uses a single namespace for variables, functions and types. It is a compile-time error if there is more than one entity, other than\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:447
msgid "Draft Dart Programming Language Specification Draft 10 a setter and a getter, with the same name declared in the same scope. Names in nested scopes may hide names in lexically enclosing scopes, however, it is a static warning if a declaration introduces a name that is available in a lexically enclosing scope."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:450
msgid "Names may be introduced into a scope by declarations within the scope or by other mechanisms such as imports or inheritance."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:455
msgid "3.2 Privacy Dart supports two levels of privacy: public and private. A declaration is private iff it begins with an underscore (the character) otherwise it is public. A declaration m is accessible to library L if m is declared in L or if m is public."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:458
msgid "This means private declarations may only be accessed within the library in which they are declared."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:464
msgid "Privacy is, at this point, a static notion tied to a particular piece of code (a library). It is designed to support software engineering concerns rather than security concerns. Untrusted code should always run in an another isolate. It is possible that libraries will become first class objects and privacy will be a dynamic notion tied to a library instance."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:469
msgid "Privacy is indicated by the name of a declaration - hence privacy and naming are not orthogonal. This has the advantage that both humans and machines can recognize access to private declarations at the point of use without knowledge of the context from which the declaration is derived."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:473
msgid "3.3 Concurrency Dart code is always single threaded. There is no shared-state concurrency in Dart. Concurrency is supported via actor-like entities called isolates."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:477
msgid "An isolate is a unit of concurrency. It has its own memory and its own thread of control. Isolates communicate by message passing (10.14.4). No state is ever shared between isolates. Isolates are created by spawning (10.11)."
msgstr "Isolateとは並行性の単位である。それらは、個別のメモリと制御スレッドを所有する。Isolateはメッセージパッシング (10.14.4) によって通信を行う。また、Isolate間で状態が共有されることは無い。Isolateはspawning (10.11) によって生成される。"

#. type: Plain text
#: dartLangSpec.txt:480
msgid "4 Errors and Warnings This specification distinguishes between several kinds of errors."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:483
msgid "Compile-time errors are errors that preclude execution. A compile-time error must be reported by a Dart compiler before the erroneous code is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:489
msgid "A Dart implementation has considerable freedom as to when compilation takes place. Modern programming language implementations often interleave compilation and execution, so that compilation of a method may be delayed, e.g., until it is first invoked. Consequently, compile-time errors in a method m may be reported as late as the time of m's first invocation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:491
msgid "As a web language, Dart is often loaded directly from source, with no intermediate binary representation. In the interests of rapid loading, Dart implementations may choose to avoid full parsing of method bodies, for example. This can\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:496
msgid "Draft Dart Programming Language Specification Draft 11 be done by tokenizing the input and checking for balanced curly braces on method body entry. In such an implementation, even syntax errors will be detected only when the method needs to be executed, at which time it will be compiled (JITed)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:499
msgid "In a development environment a compiler should of course report compilation errors eagerly so as to best serve the programmer."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:502
msgid "If a compile-time error occurs within the code of a running isolate A, A is immediately suspended."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:512
msgid "Typically, A will then be terminated. However, this depends on the overall environment. A Dart engine runs in the context of an embedder, a program that interfaces between the engine and the surrounding computing environment. The embedder will often be a web browser, but need not be; it may be a C++ program on the server for example. When an isolate fails with a compile-time error as described above, control returns to the embedder, along with an exception describing the problem. This is necessary so that the embedder can clean up resources etc. It is then the embedders decision whether to terminate the isolate or not."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:517
msgid "Static warnings are those errors reported by the static checker. They have no effect on execution. Many, but not all, static warnings relate to types, in which case they are known as static type warnings. Static warnings must be provided by Dart compilers used during development."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:523
msgid "Dynamic type errors are type errors reported in checked mode.  Run-time errors are exceptions raised during execution. Whenever we say that an exception ex is raised or thrown, we mean that a throw statement (11.14)  of the form: throw ex; was implicitly executed. When we say that a C is thrown, where C is a class, we mean that an instance of class C is thrown."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:526
msgid "5 Variables Variables are storage locations in memory."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:528
msgid "variableDeclaration:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:531
msgid "declaredIdentifier (`, ' identifier)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:533
msgid "initializedVariableDeclaration:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:536
msgid "declaredIdentifier (`=' expression)? (`, ' initializedIdentifier)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:538
msgid "initializedIdentifierList:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:541
msgid "initializedIdentifier (`, ' initializedIdentifier)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:543
msgid "initializedIdentifier:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:545
msgid "identifier (`=' expression)?\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:547
msgid "Draft Dart Programming Language Specification Draft 12"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:550
msgid "; declaredIdentifier:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:553
msgid "finalVarOrType identifier ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:555
msgid "finalVarOrType:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:560
msgid "final type? | var | type ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:565
msgid "A variable that has not been initialized has the initial value null (10.2). A final variable is a variable whose declaration includes the modifier final. A final variable can only be assigned once, when it is initialized, or a compile-time error occurs."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:568
msgid "A static variable is a variable that is not associated with a particular instance, but rather with an entire library or class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:571
msgid "A variable that is both static and final must be initialized to a compile-time constant (10.1) or a compile-time error occurs."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:575
msgid "Why tie together two orthogonal concepts like static and final by requiring the use of constants? Because we do not want a language where expensive initialization computations are defined, causing long application startup times. This is especially crucial for Dart, which is designed for coding client applications."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:578
msgid "One time initializations using constants should incur negligible cost at run time."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:581
msgid "If a variable declaration does not explicitly specify a type, the type of the declared variable(s) is Dynamic, the unknown type (13.6)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:584
msgid "A top-level variable is implicitly static. It is a compile-time error to preface a top level variable declaration with the built-in identifier (10.28) static."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:586
msgid "It is a compile-time error if a top level variable is initialized with an expression that is not a compile-time constant."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:589
msgid "6 Functions Functions abstract over executable actions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:591
msgid "functionSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:594
msgid "returnType? identifier formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:596
msgid "returnType:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:599
msgid "void | type\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:601
msgid "Draft Dart Programming Language Specification Draft 13"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:604
msgid "; functionBody:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:608
msgid "`=>' expression `;' | block ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:610
msgid "block:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:613
msgid "`{' statements `}' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:616
msgid "Functions include function declarations (6.1), methods (7.1, 7.6), getters (7.2), setters (7.3), constructors (7.5) and function literals (10.8)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:621
msgid "All functions have a signature and a body. The signature describes the formal parameters of the function, and possibly its name and return type. The body is a block statement (11.1) containing the statements (11) executed by the function. A function body of the form => e is equivalent to a body of the form{"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:623
msgid "return e;}."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:626
msgid "If the last statement of a function is not a return statement, the statement return null; is implicitly appended to the function body."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:630
msgid "Because Dart is optionally typed, we cannot guarantee that a function that does not return a value will not be used in the context of an expression. Therefore, every function must return a value. See further discussion in section 11.10."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:635
msgid "6.1 Function Declarations A function declaration is a function that is not a method, getter, setter or function literal. Function declarations include library functions, which are function declarations at the top level of a library, and local functions, which are function declarations declared inside other functions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:645
msgid "A function declaration of the form T0 id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk){s} is equivalent to a variable declaration of the form final F id = (T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){s}, where F is the function type alias (13.3.1) typedef T0 F (T1 a1, . . . , Tn an, [Tn+1 xn+1, . . . , Tn+k xn+k]). Likewise, a function declaration of the form id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){s} is equivalent to a variable declaration of the form final F id = (T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){s}, where F is the function type alias typedef F (T1 a1, . . . , Tn an, [Tn+1 xn+1, . . . , Tn+k xn+k])."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:650
msgid "Some obvious conclusions: A function declaration of the form id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]) => e is equivalent to a variable declaration of the form final id = ((T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]) => e.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:652
msgid "Draft Dart Programming Language Specification Draft 14"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:656
msgid "A function literal of the form (T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]) => e is equivalent to a function literal of the form (T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){ return e;}."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:659
msgid "It is a compile-time error to preface a function declaration with the built-in identifier static."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:664
msgid "6.2 Formal Parameters Every function declaration includes a formal parameter list, which consists of a list of required parameters, followed by any optional parameters. Optional parameters consist of a list of named parameters."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:667
msgid "The scope of formal parameters includes, but is distinct from, the scope of the function body."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:669
msgid "formalParameterList:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:674
msgid "`(' `)' | `(' normalFormalParameters ( `, ' namedFormalParameters)? `)' | (namedFormalParameters)  ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:676
msgid "normalFormalParameters:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:679
msgid "normalFormalParameter (`, ' normalFormalParameter)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:681
msgid "namedFormalParameters:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:684
msgid "`[' defaultFormalParameter (`, ' defaultFormalParameter)* `]' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:687
msgid "6.2.1 Positional Formals A positional formal parameter is a simple variable declaration (5)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:689
msgid "normalFormalParameter:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:694
msgid "functionSignature | fieldFormalParameter | simpleFormalParameter ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:696
msgid "simpleFormalParameter:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:700
msgid "declaredIdentifier | identifier ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:702
msgid "fieldFormalParameter:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:704
msgid "finalVarOrType? this `.' identifier\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:706
msgid "Draft Dart Programming Language Specification Draft 15"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:710
msgid "; 6.2.2 Named Optional Formals Optional parameters may be specified and provided with default values."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:712
msgid "defaultFormalParameter:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:715
msgid "normalFormalParameter ('=' expression)? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:720
msgid "It is a compile-time error if the default value of a named parameter is not a compile-time constant (10.1). If no default is explicitly specified for an optional parameter, but a default could legally be provided, an implicit default of null is provided."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:724
msgid "There are situations (in abstract methods and interfaces) where optional parameters are allowed but an explicit default is illegal. In these cases, no implicit default is provided. This causes no difficulty, as any implementation of the method will provide defaults."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:727
msgid "It is a compile-time error if the name of a named optional parameter begins with an character."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:735
msgid "The need for this restriction is a direct consequence of the fact that naming and privacy are not orthogonal. If we allowed named parameters to begin with an underscore, they would be considered private and inaccessible to callers from outside the library where it was defined. If a method outside the library overrode a method with a private optional name, it would not be a subtype of the original method. The static checker would of course flag such situations, but the consequence would be that adding a private named formal would break clients outside the library in a way they could not easily correct."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:740
msgid "6.3 Type of a Function If a function does not declare a return type explicitly, its return type is Dynamic. Let F be a function with required formal parameters T1 p1 . . . , Tn pn, return type T0 and named optional parameters Tn+1 pn+1, . . . , Tn+k pn+k. Then the type of F is (T1, . . . , Tn, [Tn+1 pn+1, . . . , Tn+k pn+k]) ! T0."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:743
msgid "7 Classes A class defines the form and behavior of a set of objects which are its instances."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:745
msgid "classDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:748
msgid "abstract? class identifier typeParameters? superclass? interfaces? `{' classMemberDefinition* `}'\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:750
msgid "Draft Dart Programming Language Specification Draft 16"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:753
msgid "; classMemberDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:757
msgid "declaration `;' | methodSignature functionBody ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:759
msgid "methodSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:767
msgid "factoryConstructorSignature | static? functionSignature | getterSignature | setterSignature | operatorSignature | constructorSignature initializers? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:769
msgid "declaration:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:779
msgid "constantConstructorSignature (redirection | initializers)? | constructorSignature (redirection | initializers)? | abstract getterSignature | abstract setterSignature | abstract operatorSignature | abstract functionSignature | static final type? staticFinalDeclarationList | static? initializedVariableDeclaration ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:781
msgid "staticFinalDeclarationList:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:785
msgid ": staticFinalDeclaration (', ' staticFinalDeclaration)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:787
msgid "staticFinalDeclaration:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:790
msgid "identifier '=' expression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:794
msgid "A class has constructors, instance members and static members. The instance members of a class are its instance methods, getters, setters and instance variables. The static members of a class are its static methods, getters, setters and static variables."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:797
msgid "Every class has a single superclass except class Object which has no superclass. A class may implement a number of interfaces by declaring them in its implements clause (7.9).\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:799
msgid "Draft Dart Programming Language Specification Draft 17"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:802
msgid "An abstract class is either a class that is explicitly declared with the abstract modifier, or a class that declares at least one abstract method (7.1.1)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:813
msgid "The abstract modifier for classes is not implemented. It is intended to be used in scenarios where an abstract class A inherits from another abstract class B. In such a situation, it may be that A itself does not declare any abstract methods.  In the absence of an abstract modifier on the class, the class would be interpreted as a concrete class. However, we want different behavior for concrete classes and abstract classes. If A is intended to be abstract, we want the static checker to warn about any attempt to instantiate A, and we do not want the checker to complain about unimplemented methods in A. In contrast, if A is intended to be concrete, the checker should warn about all unimplemented methods, but allow clients to instantiate it freely."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:817
msgid "The interface of class C is an implicit interface that declares instance members that correspond to the instance members declared by C, and whose direct superinterfaces are the direct superinterfaces of C (7.9). When a class name appears as a type or interface, that name denotes the interface of the class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:821
msgid "It is a compile-time error if a class declares two members of the same name, except that a getter and a setter may be declared with the same name provided both are instance members or both are static members."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:824
msgid "What about a final instance variable and a setter? This case is illegal as well. If the setter is setting the variable, the variable should not be final."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:828
msgid "It is a compile-time error if a class has two member variables with the same name. It is a compile-time error if a class has an instance method and a static member method with the same name."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:833
msgid "7.1 Instance Methods Instance methods are functions (6) whose declarations are immediately contained within a class declaration and that are not declared static. The instance methods of a class C are those instance methods declared by C and the instance methods inherited by C from its superclass."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:839
msgid "It is a compile-time error if an instance method m1 overrides (7.8.1) an instance member m2 and m1 has a different number of required parameters than m2. It is a compile-time error if an instance method m1 overrides an instance member m2 and m1 does not declare all the named parameters declared by m2 in the same order."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:844
msgid "It is a static warning if an instance method m1 overrides an instance member m2 and the type of m1 is not a subtype of the type of m2. It is a static warning if a class C declares an instance method named n and a static member named n is declared in a superclass of C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:848
msgid "7.1.1 Abstract Methods An abstract method declares an instance method without providing an implementation. The declaration of an abstract method is prefixed by the built-in identifier (10.28) abstract. It is a compile-time error if any default values are\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:852
msgid "Draft Dart Programming Language Specification Draft 18 specified in the signature of an abstract method. This could all be enforced syntactically."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:856
msgid "Invoking an abstract method always results in a run-time error. This must be NoSuchMethodError or or an instance of a subclass of NoSuchMethodError, such as AbstractMethodError."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:860
msgid "These errors are ordinary objects and are therefore catchable.  Unless explicitly stated otherwise, all ordinary rules that apply to methods apply to abstract methods."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:863
msgid "7.1.2 Operators Operators are instance methods with special names."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:865
msgid "operatorSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:868
msgid "returnType? operator operator formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:870
msgid "operator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:878
msgid "unaryOperator | binaryOperator | '[]' | '[]=' | negate | call ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:880
msgid "unaryOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:883
msgid "negateOperator ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:885
msgid "binaryOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:893
msgid "multiplicativeOperator | additiveOperator | shiftOperator | relationalOperator | equalityOperator | bitwiseOperator ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:895
msgid "prefixOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:899
msgid "'-' | negateOperator ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:901
msgid "Draft Dart Programming Language Specification Draft 19"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:903
msgid "negateOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:907
msgid "' !' | '~' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:909
msgid "An operator declaration is identified using the built-in identifier (10.28) operator."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:912
msgid "The following names are allowed for user-defined operators: ==, <, >, <=, >=, -, +, /, ~/, *, %, |, ^, &, <<, >>, []=, [], ~, call, negate."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:915
msgid "The built-in identifier negate is used to denote unary minus. The built-in identifier call is used to denote function application ( () )."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:918
msgid "Defining a nullary method named negate will have the same effect as defining an operator, but is considered bad style, and will cause a static warning."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:924
msgid "It is a compile-time error if the number of formal parameters of the userdeclared operator []= is not 2. It is a compile-time error if the number of formal parameters of a user-declared operator with one of the names: ==, <, >, <=, >=, -, +, ~/, /, *, %, |, ^, &, <<, >>, [] is not 1. It is a compile-time error if the arity of a user-declared operator with one of the names: ~, negate is not 0. The operator call can have any arity."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:927
msgid "It is a compile-time error to declare an optional named parameter in an operator, with the exception of the operator call."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:930
msgid "Defining a method named call will have the same effect as defining an operator but is considered bad style, and will cause a warning."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:938
msgid "It is tempting to define it to be a compile-time error to declare a method named call or negate. However, this causes compatibility problems. Since both are built-in identifiers, unsanctioned use will cause a static warning, which is arguably sufficient to alert the programmer to the fact that the ported code is likely not intended to define an operator. In fresh Dart code, the warning will indicate that either the built-in identifier operator was forgotten, or that the method should have a different name."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:941
msgid "It is a static warning if the return type of the user-declared operator []= is not void."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:944
msgid "7.2 Getters Getters are functions (6) that are used to retrieve the values of object properties."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:946
msgid "getterSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:949
msgid "static? returnType? get identifier formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:954
msgid "If no return type is specified, the return type of the getter is Dynamic.  A getter definition that is prefixed with the static modifier defines a static getter. Otherwise, it defines an instance getter. The name of the getter is given by the identifier in the definition.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:956
msgid "Draft Dart Programming Language Specification Draft 20"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:961
msgid "It is a compile-time error if a getter`s formal parameter list is not empty.  It is a compile-time error if a class has both a getter and a method with the same name. This restriction holds regardless of whether the getter is defined explicitly or implicitly, or whether the getter or the method are inherited or not."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:964
msgid "This implies that a getter can never override a method, and a method can never override a getter or field."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:967
msgid "It is a static warning if a getter m1 overrides (7.8.1) a getter m2 and the type of m1 is not a subtype of the type of m2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:970
msgid "7.3 Setters Setters are functions (6) that are used to set the values of object properties."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:972
msgid "setterSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:975
msgid "static? returnType? set identifier formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:980
msgid "If no return type is specified, the return type of the setter is Dynamic.  A setter definition that is prefixed with the static modifier defines a static setter. Otherwise, it defines an instance setter. The name of the setter is given by the identifier in the definition."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:984
msgid "It is a compile-time error if a setter's formal parameter list does not consist of exactly one required formal parameter p. We could enforce this via the grammar, but we`d have to specify the evaluation rules in that case."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:988
msgid "It is a compile-time error if a class has both a setter and a method with the same name. This restriction holds regardless of whether the setter is defined explicitly or implicitly, or whether the setter or the method are inherited or not."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:991
msgid "Hence, a setter can never override a method, and a method can never override a setter."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:997
msgid "It is a static warning if a setter declares a return type other than void. It is a static warning if a setter m1 overrides (7.8.1) a setter m2 and the type of m1 is not a subtype of the type of m2. It is a static warning if a class has a setter with argument type T and a getter of the same name with return type S, and T may not be assigned to S."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1002
msgid "7.4 Instance Variables Instance variables are variables whose declarations are immediately contained within a class declaration and that are not declared static. The instance variables of a class C are those instance variables declared by C and the instance variables inherited by C from its superclass."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1006
msgid "It is a compile-time error if an instance variable declaration has one of the forms T v = e;, var v = e;, final T v = e; or final v = e; and the expression e is not a compile-time constant (10.1).\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1008
msgid "Draft Dart Programming Language Specification Draft 21"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1012
msgid "In Dart, all uninitialized variables have the value null, regardless of type.  Numeric variables in particular are therefore best explicitly initialized; such variables will not be initialized to 0 by default. The form above is intended to ease the burden of such initialization."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1016
msgid "An instance variable declaration of one of the forms T v;, final T v; , T v = e; or final T v = e; always induces an implicit getter function (7.2) with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1021
msgid "T get v()  whose invocation evaluates to the value stored in v.  An instance variable declaration of one of the forms var v;, final v;, var v = e; or final v = e; always induces an implicit getter function with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1026
msgid "get v()  whose invocation evaluates to the value stored in v.  Getters are introduced for all instance and static variables (7.7), regardless of whether they are final or not."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1029
msgid "A non-final instance variable declaration of the form T v; or the form T v = e; always induces an implicit setter function (7.3) with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1034
msgid "void set v(T x)  whose execution sets the value of v to the incoming argument x.  A non-final instance variable declaration of the form var v; or the form var v = e; always induces an implicit setter function with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1037
msgid "set v(x)  whose execution sets the value of v to the incoming argument x."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1042
msgid "7.5 Constructors A constructor is a special member that is used in instance creation expressions (10.10) to produce objects. Constructors may be generative or they may be factories."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1046
msgid "A constructor name always begins with the name of its immediately enclosing class or interface, and may optionally be followed by a dot and an identifier.  The name of a non-factory constructor must be a constructor name."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1049
msgid "Interfaces can have constructor declarations (but not bodies). See the discussion of factories."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1051
msgid "Iff no constructor is specified for a class C, it implicitly has a default constructor C() : super() {}, unless it is class Object."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1055
msgid "7.5.1 Generative Constructors A generative constructor consists of a constructor name, a constructor parameter list, an initializer list and an optional body."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1057
msgid "constructorSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1060
msgid "identifier formalParameterList | namedConstructorSignature\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1062
msgid "Draft Dart Programming Language Specification Draft 22"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1065
msgid "; namedConstructorSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1068
msgid "identifier `.' identifier formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1077
msgid "A constructor parameter list is a parenthesized, comma-separated list of formal constructor parameters. A formal constructor parameter is either a formal parameter (6.2) or an initializing formal. An initializing formal has the form this.id, where id is the name of an instance variable of the immediately enclosing class. It is a compile-time error if an initializing formal is used by function other than a non-redirecting generative constructor. Using an initializing formal this.id in a formal parameter list does not introduce a formal parameter name into the scope of the constructor. However, the initializing formal does effect the type of the constructor function exactly as if a formal parameter named id in the same position would."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1080
msgid "The above rule allows initializing formals to be used as optional parameters: class A {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1083
msgid "var x; A([this.x]);}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1086
msgid "is legal, and has the same effect as class A {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1089
msgid "var x; A([x]): this.x = x;}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1094
msgid "No warning is issued over shadowing in this case.  A fresh instance is an instance whose identity is distinct from any previously allocated instance of the class. A generative constructor always allocates a fresh instance of its immediately enclosing class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1098
msgid "The above holds if the constructor is actually run, as it is by new. If a constructor c is referenced by const, c may not be run; instead, a canonical object may be looked up. See the section on instance creation (10.10)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1101
msgid "If a generative constructor c is not a redirecting constructor and no body is provided, then c implicitly has an empty body {}."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1105
msgid "Redirecting Constructors A generative constructor may be redirecting, in which case its only action is to invoke another generative constructor. A redirecting constructor has no body; instead, it has a redirect clause that specifies which constructor the invocation is redirected to, and with what arguments."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1107
msgid "redirection:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1110
msgid "`:' this (`.' identifier)? arguments ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1114
msgid "Draft Dart Programming Language Specification Draft 23 Initializer Lists An initializer list begins with a colon, and consists of a comma-separated list of individual initializers. There are two kinds of initializers."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1117
#, no-wrap
msgid ""
"* A superinitializer specifies a superconstructor - that is, a specific constructor of the superclass. Execution of the superinitializer causes the initializer\n"
"list of the superconstructor to be executed.\n"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1119
msgid "An instance variable initializer assigns a value to an individual instance"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1121
msgid "variable."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1123
msgid "initializers:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1126
msgid "`:' superCallOrFieldInitializer (`, ' superCallOrFieldInitializer)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1128
msgid "superCallOrFieldInitializer:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1133
msgid "super arguments | super `.' identifier arguments | fieldInitializer ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1135
msgid "fieldInitializer:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1138
msgid "(this `.')? identifier `=' conditionalExpression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1144
msgid "Let k be a generative constructor. Then k may include at most one superinitializer in its initializer list or a compile-time error occurs. If no superinitializer is provided, an implicit superinitializer of the form super() is added at the end of k's initializer list, unless the enclosing class is class Object. It is a compiletime error if more than one initializer corresponding to a given instance variable appears in k's initializer list. It is a compile-time error if k's initializer list contains an initializer for a variable that is initialized by means of an initializing formal of k."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1148
msgid "Each final instance variable f declared in the immediately enclosing class must have an initializer in k's initializer list unless it has already been initialized by one of the following means:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1150
msgid "Initialization at the declaration of f ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1155
#, no-wrap
msgid ""
"* Initialization by means of an initializing formal of k.\n"
"or a compile-time error occurs. It is a compile-time error if k's initializer list\n"
"contains an initializer for a variable that is not an instance variable declared in\n"
"the immediately surrounding class.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1158
msgid "The initializer list may of course contain an initializer for any instance variable declared by the immediately surrounding class, even if it is not final.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1160
msgid "Draft Dart Programming Language Specification Draft 24"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1163
msgid "It is a compile-time error if a generative constructor of class Object includes a superinitializer."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1173
msgid "Execution of a generative constructor proceeds as follows: First, a fresh instance (7.5.1) i of the immediately enclosing class is allocated.  Next, the instance variable declarations of the immediately enclosing class are visited in the order they appear in the program text. For each such declaration d, if d has the form f inalV arOrT ype v = e; then the instance variable v of i is bound to the value of e (which is necessarily a compile-time constant).  Next, any initializing formals declared in the constructor's parameter list are executed in the order they appear in the program text. Then, the constructor's initializers are executed in the order they appear in the program."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1176
msgid "We could observe the order by side effecting external routines called. So we need to specify the order."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1180
msgid "After all the initializers have completed, the body of the constructor is executed in a scope where this is bound to i. Execution of the body begins with execution of the body of the superconstructor with respect to the bindings determined by the argument list of the superinitializer of k."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1186
msgid "This process ensures that no uninitialized final field is ever seen by code.  Note that this is not in scope on the right hand side of an initializer (see 10.9)  so no instance method can execute during initialization: an instance method cannot be directly invoked, nor can this be passed into any other code being invoked in the initializer."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1190
msgid "Execution of an initializer of the form this.v = e proceeds as follows: First, the expression e is evaluated to an object o. Then, the instance variable v of the object denoted by this is bound to o."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1193
msgid "An initializer of the form v = e is equivalent to an initializer of the form this.v = e."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1197
msgid "Execution of a superinitializer of the form super(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) (respectively super.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1199
msgid "First, the argument list (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1203
msgid "Let C be the class in which the superinitializer appears and let S be the superclass of C. If S is generic (9), let U1, , . . . , Um be the actual type parameters passed to S in the superclass clause of C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1208
msgid "Then, the initializer list of the constructor S (respectively S.id) is executed with respect to the bindings that resulted from the evaluation of the argument list, with this bound to the current binding of this, and the type parameters (if any) of class S bound to the current bindings of U1, , . . . , Um."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1211
msgid "It is a compile-time error if class S does not declare a constructor named S (respectively S.id)"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1214
msgid "7.5.2 Factories A factory is a constructor prefaced by the built-in identifier (10.28) factory.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1216
msgid "Draft Dart Programming Language Specification Draft 25"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1218
msgid "factoryConstructorSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1221
msgid "factory qualified (`.' identifier)? formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1223
msgid "It is a static warning if the name of the method is not either:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1225
msgid "A constructor name."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1227
msgid "The name of a constructor of an interface that is in scope at the point"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1229
msgid "where the factory is declared."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1234
msgid "The return type of a factory whose signature is of the form factory M or the form factory M.id is M if M is not a generic type; otherwise the return type is. M < T1, . . . , Tn > where T1, . . . , Tn are the type parameters of the enclosing class"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1237
msgid "We are guaranteed that M has n type parameters because an interface and its factory class must have the same number of type parameters."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1240
msgid "It is a compile-time error if M is not the name of the immediately enclosing class or the name of an interface in the enclosing lexical scope."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1243
msgid "In checked mode, it is a dynamic type error if a factory returns an object whose type is not a subtype of its actual (13.8.1) return type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1246
msgid "It seems useless to allow a factory to return null. But it is more uniform to allow it, as the rules currently do."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1251
msgid "Factories address classic weaknesses associated with constructors in other languages. Factories can produce instances that are not freshly allocated: they can come from a cache. Likewise, factories can return instances of different classes."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1255
msgid "7.5.3 Constant Constructors A constant constructor may be used to create compile-time constant (10.1) objects. A constant constructor is prefixed by the reserved word const. It is a compile-time error if a constant constructor has a body."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1257
msgid "constantConstructorSignature:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1260
msgid "const qualified formalParameterList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1264
msgid "All the work of a constant constructor must be handled via its initializers.  It is a compile-time error if a constant constructor is declared by a class that has a non-final instance variable."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1267
msgid "The above refers to both locally declared and inherited instance variables.  Any expression that appears within the initializer list of a constant constructor must be a potentially constant expression, or a compile-time error occurs."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1270
msgid "A potentially constant expression is an expression e that would be a valid constant expression if all formal parameters of es immediately enclosing constant\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1275
msgid "Draft Dart Programming Language Specification Draft 26 constructor were treated as compile-time constants that were guaranteed to evaluate to an integer, boolean or string value as required by their immediately enclosing superexpression."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1278
msgid "The difference between a potentially constant expression and a compile-time constant expression (10.10.2) deserves some explanation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1281
msgid "The key issue is whether one treats the formal parameters of a constructor as compile-time constants."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1286
msgid "If a constant constructor is invoked from a constant object expression, the actual arguments will be required to be compile-time constants. Therefore, if we were assured that constant constructors were always invoked from constant object expressions, we could assume that the formal parameters of a constructor were compile-time constants."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1288
msgid "However, constant constructors can also be invoked from ordinary instance creation expressions (10.10.1), and so the above assumption is not generally valid."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1293
msgid "Nevertheless, the use of the formal parameters of a constant constructor within the constructor is of considerable utility. The concept of potentially constant expressions is introduced to facilitate limited use of such formal parameters. Specifically, we allow the usage of the formal parameters of a constant constructor for expressions that involve built-in operators, but not for constant objects, lists and maps.  This allows for constructors such as:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1295
msgid "class C {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1298
msgid "final x; final y; final z; const C(p, q): x = q, y = p + 100, z = p + q;}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1306
msgid "The assignment to x is allowed under the assumption that q is a compile-time constant (even though q is not, in general a compile-time constant). The assignment to y is similar, but raises additional questions. In this case, the superexpression of p is p + 100, and it requires that p be a numeric compile-time constant for the entire expression to be considered constant. The wording of the specification allows us to assume that p evaluates to an integer. A similar argument holds for p and q in the assignment to z."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1309
msgid "However, the following constructors are disallowed: class D {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1314
msgid "final w; const D.makeList(p): w = const [p]; // compile-time error const D.makeMap(p): w = const {help: q}; // compile-time error const D.makeC(p): w = const C(p, 12); // compile-time error}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1319
msgid "The problem is not that the assignments to w are not potentially constant; they are. However, all these run afoul of the rules for constant lists (10.6), maps (10.7)  and objects (10.10.2), all of which independently require their subexpressions to constant expressions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1323
msgid "All of the illegal constructors of D above could not be sensibly invoked via new, because an expression that must be constant cannot depend on a formal parameter, which may or may not be constant. In contrast, the legal examples\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1327
msgid "Draft Dart Programming Language Specification Draft 27 make sense regardless of whether the constructor is invoked via const or via new."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1331
msgid "Careful readers will of course worry about cases where the actual arguments to C() are constants, but are not numeric. This is precluded by the following rule, combined with the rules for evaluating constant objects (10.10.2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1336
msgid "When invoked from a constant object expression, a constant constructor must throw an exception if any of its actual parameters would be a value that would cause one of the potentially constant expressions within it to not be a valid compile-time constant."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1341
msgid "7.6 Static Methods Static methods are functions whose declarations are immediately contained within a class declaration and that are declared static. The static methods of a class C are those static methods declared by C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1347
msgid "Inheritance of static methods has little utility in Dart. Static methods cannot be overridden. Any required static function can be obtained from its declaring library, and there is no need to bring it into scope via inheritance. Experience shows that developers are confused by the idea of inherited methods that are not instance methods."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1351
msgid "Of course, the entire notion of static methods is debatable, but it is retained here because so many programmers are familiar with it. Dart static methods may be seen as functions of the enclosing library."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1356
msgid "7.7 Static Variables Static variables are variables whose declarations are immediately contained within a class declaration and that are declared static. The static variables of a class C are those static variables declared by C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1360
msgid "A static variable declaration of one of the forms static T v;, static T v = e; or static final T v = e; always induces an implicit static getter function (7.2)  with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1366
msgid "static T get v()  whose invocation evaluates to the value stored in v.  A static variable declaration of one of the forms static var v;, static var v = e; or static final v = e; always induces an implicit static getter function with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1372
msgid "static get v()  whose invocation evaluates to the value stored in v.  A non-final static variable declaration of the form static T v; or the form static T v = e; always induces an implicit static setter function (7.3) with signature"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1377
msgid "static void set v(T x)  whose execution sets the value of v to the incoming argument x.  A static variable declaration of the form static var v; or the form static var v = e; always induces an implicit static setter function with signature\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1379
msgid "Draft Dart Programming Language Specification Draft 28"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1382
msgid "static set v(x)  whose execution sets the value of v to the incoming argument x."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1386
msgid "7.8 Superclasses The extends clause of a class C specifies its superclass. If no extends clause is specified, then either:*"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1388
msgid "C is Object, which has no superclass. OR"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1391
#, no-wrap
msgid ""
"* The superclass of C is Object.\n"
"It is a compile-time error to specify an extends clause for class Object.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1393
msgid "superclass:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1396
msgid "extends type ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1399
msgid "It is a compile-time error if the extends clause of a class C includes a type expression that does not denote a class available in the lexical scope of C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1401
msgid "A class S is a superclass of a class C iff either:*"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1403
msgid "S is the superclass of C, or"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1406
#, no-wrap
msgid ""
"* S is a superclass of a class S0 and S0 is a superclass of C.\n"
"It is a compile-time error if a class C is a superclass of itself.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1410
msgid "7.8.1 Inheritance and Overriding A class C inherits any instance members of its superclass that are not overridden by members declared in C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1413
msgid "A class may override instance members that would otherwise have been inherited from its superclass."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1418
msgid "Let C be a class declared in library L, with superclass S and let C declare an instance member m, and assume S declares an instance member m0 with the same name as m. Then m overrides m0 iff m is accessible (3.2) to L and one of the following holds:*"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1420
#: dartLangSpec.txt:1636
msgid "m is an instance method."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1422
msgid "m is a getter and m0 is a getter or a method."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1428
#, no-wrap
msgid ""
"* m is a setter and m0 is a setter or a method.\n"
"Whether an override is legal or not is described elsewhere in this specification.\n"
"For example getters and setters may not legally override methods and vice versa.\n"
"It is nevertheless convenient to define the override relation between members\n"
"in this way, so that we can concisely describe the illegal cases.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1432
msgid "Note that instance variables do not participate in the override relation, but the getters and setters they induce do. Also, getters don`t override setters and vice versa. Finally, static members never override anything.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1438
msgid "Draft Dart Programming Language Specification Draft 29 7.9 Superinterfaces A class has a set of direct superinterfaces. This set includes the interface of its superclass and the interfaces specified in the the implements clause of the class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1440
msgid "interfaces:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1443
msgid "implements typeList ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1447
msgid "It is a compile-time error if the implements clause of an class C includes a type expression that does not denote a class or interface available in the lexical scope of C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1452
msgid "In particular, one cannot inherit from a type variable.  It is a compile-time error if the implements clause of a class includes type Dynamic. It is a compile-time error if a type T appears more than once in the implements clause of a class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1461
msgid "One might argue that it is harmless to repeat a type in this way, so why make it an error? The issue is not so much that the situation described in program source is erroneous, but that it is pointless. As such, it is an indication that the programmer may very well have meant to say something else - and that is a mistake that should be called to her or his attention. Nevertheless, we could simply issue a warning; and perhaps we should and will. That said, problems like these are local and easily corrected on the spot, so we feel justified in taking a harder line."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1463
msgid "It is a compile-time error if the interface induced by a class C is a superinterface of itself."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1466
msgid "A class does not inherit members from its superinterfaces. However, its implicit interface does."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1470
msgid "8 Interfaces An interface defines how one may interact with an object. An interface has methods, getters, setters and constructors, and a set of superinterfaces."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1472
msgid "interfaceDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1474
msgid "interface identifier typeParameters? superinterfaces? factorySpecification? `{' (interfaceMemberDefinition)* `}'"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1476
#: dartLangSpec.txt:1993
#: dartLangSpec.txt:2254
#: dartLangSpec.txt:3463
#: dartLangSpec.txt:4009
#: dartLangSpec.txt:4137
msgid ";"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1478
msgid "interfaceMemberDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1483
msgid "static final type? initializedIdentifierList `;' | functionSignature `;' | constantConstructorSignature `;' | namedConstructorSignature `;' |\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1485
msgid "Draft Dart Programming Language Specification Draft 30"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1491
msgid "getterSignature `;' | setterSignature `;' | operatorSignature `;' | variableDeclaration `;' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1494
msgid "It is a compile-time error if any default values are specified in the signature of an interface method, getter, setter or constructor."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1497
msgid "8.1 Methods An interface method declaration specifies a method signature but no body."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1503
msgid "It is a compile-time error if an interface method m1 overrides (8.4.1) an interface member m2 and m1 has a different number of required parameters than m2. It is a compile-time error if an interface method m1 overrides an interface member m2 and m1 does not declare all the named parameters declared by m2 in the same order."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1506
msgid "It is a static warning if an interface method m1 overrides an interface method m2 and the type of m1 is not a subtype of the type of m2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1510
msgid "8.1.1 Operators Operators are instance methods with special names. Some, but not all, operators may be defined by user code, as described in section 7.1.2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1515
msgid "8.2 Getters and Setters An interface may contain getter and/or setter signatures. These are subject to the same compile-time and static checking rules as getters and setters in classes (7.2, 7.3)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1519
msgid "8.3 Factories and Constructors An interface may specify a default factory class, which is a class that will be used to provide instances when constructors are invoked via the interface."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1521
msgid "factorySpecification:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1524
msgid "default qualified typeParameters? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1527
msgid "An interface can specify the signatures of constructors that are used to provide objects that conform to the interface. It is a compile-time error if an interface declares a constructor without declaring a factory class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1530
msgid "Let I be an interface named NI with factory class F , and let NF be the name of F . It is a compile-time error if I and F do not have the same number\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1535
msgid "Draft Dart Programming Language Specification Draft 31 of type parameters. If I has n type parameters, then the nam eof the ith type parameter of I must be identical to the name of theith type parameter of F , for i 2 1..n."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1538
msgid "A constructor kI of I corresponds to a constructor kF of its factory class F iff either"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1540
msgid "F does not implement I and kI and kF have the same name, OR"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1542
msgid "F implements I and either"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1545
msgid "- kI is named NI and kF is named NF , OR - kI is named NI .id and kF is named NF .id."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1548
msgid "It is a compile-time error if an interface I declares a constructor kI and there is no constructor kF in the factory class F such that kI corresponds to kF ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1550
msgid "Let kI be a constructor declared in an interface I, and let kF be its corresponding constructor. Then:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1552
msgid "It is a compile-time error if kI and kF do not have the same number of"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1554
msgid "required parameters."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1556
msgid "It is a compile-time error if kI and kF do not have identically named"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1558
msgid "optional parameters, declared in the same order."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1560
msgid "It is a static type warning if the type of the nth required formal parameter"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1563
msgid "of kI is not identical to the type of the nth required formal parameter of kF ."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1565
msgid "It is a static type warning if the types of named optional parameters with"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1567
msgid "the same name differ between kI and kF ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1571
msgid "If the default factory clause of I includes a list of type parameters tps, then tps must be identical to the type parameters given in the declaration of F , or a compile-time error occurs."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1575
msgid "As an example, consider class HashMapImplementaion<K extends Hashable, V>{...} interface Map<K, V> default HashMapImplementation<K, V> { ... } // illegal"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1577
msgid "interface Map<K, V> default HashMapImplementation<K extends Hashable, V> { ... } // legal"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1581
msgid "8.4 Superinterfaces An interface has a set of direct superinterfaces. This set consists of the interfaces specified in the extends clause of the interface."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1583
msgid "superinterfaces:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1586
msgid "extends typeList ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1588
msgid "Draft Dart Programming Language Specification Draft 32"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1591
msgid "An interface J is a superinterface of an interface I iff either J is a direct superinterface of I or J is a superinterface of a direct superinterface of I."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1597
msgid "It is a compile-time error if the extends clause of an interface I includes a type expression that does not denote a class or interface available in the lexical scope of I. It is a compile-time error if the extends clause of an interface includes type Dynamic. It is a compile-time error if an interface is a superinterface of itself."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1600
msgid "8.4.1 Inheritance and Overriding An interface I inherits any members of its superinterfaces that are not overridden by members declared in I."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1607
msgid "However, if the above rule would cause multiple members m1, . . . , mk with the same name n to be inherited (because identically named members existed in several superinterfaces) then at most one member is inherited. If the static types T1, . . . , Tk of the members m1, . . . , mk are not identical, then there must be a member mx such that Tx <: Ti, 1 <= x <= k for all i, 1 <= i <= k, or a static type warning occurs. The member that is inherited is mx, if it exists; otherwise:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1609
msgid "If all of m1, . . . , mk have the same number r of required parameters and"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1613
msgid "the same set of named parameters s, then I has a method named n, with r required parameters of type Dynamic, named parameters s of type Dynamic and return type Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1618
#, no-wrap
msgid ""
"* Otherwise none of the members m1, . . . , mk is inherited.\n"
"The only situation where the runtime would be concerned with this would be\n"
"during reflection, if a mirror attempted to obtain the signature of an interface\n"
"member.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1622
msgid "The current solution is a tad complex, but is robust in the face of type annotation changes. Alternatives: (a) No member is inherited in case of conflict.  (b) The first m is selected (based on order of superinterface list) (c) Inherited member chosen at random."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1626
msgid "(a) means that the presence of an inherited member of an interface varies depending on type signatures. (b) is sensitive to irrelevant details of the declaration and (c) is liable to give unpredictable results between implementations or even between different compilation sessions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1629
msgid "An interface may override instance members that would otherwise have been inherited from its superinterfaces."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1634
msgid "Let I be an interface declared in library L, with superinterface S and let I declare an instance member m, and assume S declares an instance member m0 with the same name as m. Then m overrides m0 iff m is accessible (3.2) to L and one of the following holds:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1638
msgid "m is a getter and m0 is a getter or a method.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1640
msgid "Draft Dart Programming Language Specification Draft 33"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1643
#, no-wrap
msgid ""
"* m is a setter and m0 is a setter or a method.\n"
"Whether an override is legal or not is described elsewhere in this specification.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1649
msgid "9 Generics A class (7), interface (8), type alias (13.3.1) or factory method (7.5.2) G may be generic, that is, G may have formal type parameters declared. A generic declaration induces a family of declarations, one for each set of actual type parameters provided in the program."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1651
msgid "typeParameter:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1655
msgid "identifier (extends type)? ; typeParameters:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1658
msgid "`<' typeParameter (`,' typeParameter)* `>' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1663
msgid "A type parameter T may be suffixed with an extends clause that specifies the upper bound for T . If no extends clause is present, the upper bound is Object. It is a static type warning if a type variable is supertype of its upper bound."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1668
msgid "The type parameters of a generic G are in scope in the bounds of all of the type parameters of G. The type parameters of a generic class or interface declaration G are also in scope in the extends and implements clauses of G (if these exist) and in the non-static members of G."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1671
msgid "Because type parameters are in scope in their bounds, we support F-bounded quantification (if you don't know what that is, don't ask)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1674
msgid "Even where type parameters are in scope there are numerous restrictions at this time:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1676
msgid "A type parameter cannot be used to name a constructor in an instance creation"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1678
msgid "expression (10.10)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1680
msgid "A type parameter cannot be used as an identifier expression (10.28)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1682
msgid "A type parameter cannot be used as a superclass or superinterface (7.8, 7.9,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1684
msgid "8.4)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1687
msgid "The normative versions of these are given in the appropriate sections of this specification. Some of these restrictions may be lifted in the future."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1692
msgid "10 Expressions An expression is a fragment of Dart code that can be evaluated at run time to yield a value, which is always an object. Every expression has an associated static type (13.1). Every value has an associated dynamic type (13.2).\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1694
msgid "Draft Dart Programming Language Specification Draft 34"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1696
msgid "expression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1700
msgid "assignableExpression assignmentOperator expression | conditionalExpression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1702
msgid "expressionList:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1705
msgid "expression (`, ' expression)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1707
msgid "primary:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1717
msgid "thisExpression | super assignableSelector | functionExpression | literal | identifier | newExpression | constantObjectExpression | `(' expression `)' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1721
msgid "10.1 Constants A constant expression is an expression whose value can never change, and that can be evaluated entirely at compile time."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1723
msgid "A constant expression is one of the following:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1725
msgid "A literal number (10.3)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1727
msgid "A literal boolean (10.4)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1729
msgid "A literal string (10.5) that does not involve string interpolation (10.5.1)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1733
msgid "It would be tempting to allow string interpolation where the interpolated value is a compile-time constant. However, this would require running the toString() method for constant objects, which could contain arbitrary code."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1735
msgid "null (10.2)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1737
msgid "A reference to a static final variable or to a final top-level variable(5)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1739
msgid "A constant constructor invocation (10.10.2)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1741
msgid "A constant list literal (10.6)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1743
msgid "A constant map literal (10.7)."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1745
msgid "An expression of one of the forms e1 == e2, e1 != e2, e1 === e2 or"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1748
msgid "e1! == e2 ,where e1 and e2 are constant expressions that evaluate to a numeric, string or boolean value.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1750
msgid "Draft Dart Programming Language Specification Draft 35"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1752
msgid "An expression of one of the forms !e, e1 && e2 or e1||e2, where e, e1 and"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1754
msgid "e2 are constant expressions that evaluate to a boolean value."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1756
msgid "An expression of one of the forms ~e, e1 ~/ e2, e1 ^ e2, e1 & e2, e1|e2,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1759
msgid "e1 >> e2 or e1 << e2, where e1 and e2 are constant expressions that evaluate to an integer value."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1761
msgid "An expression of the form e1 + e2 where e1 and e2 are either constant"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1764
msgid "expressions that both evaluate to a numeric value or constant expressions that both evaluate to a string value."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:1766
msgid "An expression of one of the forms e1 - e2, e1 * e2, e1 / e2, e1 > e2, e1 < e2,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1769
msgid "e1 >= e2, e1 <= e2 or e1 % e2, where e1 and e2 are constant expressions that evaluate to a numeric value."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1772
msgid "It is a compile-time error if evaluation of a compile-time constant would raise an exception."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1778
msgid "The above is not dependent on program control-flow. The mere presence of a compile time constant whose evaluation would fail within a program is an error. This also holds recursively: since compound constants are composed out of constants, if any subpart of a constant is would raise an exception when evaluated, that is an error."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1781
msgid "It is a compile-time error if the value of a compile-time constant expression depends on itself."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1785
msgid "As an example, consider: class CircularConsts{ // Illegal program - mutually recursive compile-time constants"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1788
msgid "static final i = j; // a compile-time constant static final j = i; // a compile-time constant}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1790
msgid "literal:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1798
msgid "nullLiteral | booleanLiteral | numericLiteral | stringLiteral | mapLiteral | listLiteral ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1801
msgid "10.2 Null The reserved word null denotes the null object."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1803
msgid "nullLiteral:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1806
msgid "null ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1808
msgid "Draft Dart Programming Language Specification Draft 36"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1814
msgid "The null object is the sole instance of the built-in class Null. Attempting to instantiate Null causes a run-time error. It is a compile-time error for a class or interface attempt to extend or implement Null. Invoking a method on null yields a NullPointerException unless the method is explicitly implemented by class Null."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1818
msgid "The static type of null is ?.  The decision to use ? instead of Null allows null to be be assigned everywhere without complaint by the static checker."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1821
msgid "Here is one way in which one might implement class Null: class Null {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1824
msgid "factory Null. () throw \"cannot be instantiated\"; noSuchMethod(InvocationMirror msg) {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1826
msgid "throw new NullPointerException();}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1828
msgid "/* other methods, such as == */}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1832
msgid "10.3 Numbers A numeric literal is either a decimal or hexadecimal integer of arbitrary size, or a decimal double."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1834
msgid "numericLiteral:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1838
msgid "NUMBER | HEX NUMBER ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1840
msgid "NUMBER:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1844
msgid "`+' ? DIGIT+ (`.' DIGIT+)? EXPONENT? | `+' ? `.' DIGIT+ EXPONENT? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1846
msgid "EXPONENT:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1849
msgid "(`e' | `E') ('+' | `-`)? DIGIT+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1851
msgid "HEX NUMBER:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1855
msgid "`0x' HEX DIGIT+ | `0X' HEX DIGIT+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1857
msgid "HEX DIGIT:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1860
msgid "`a'..'f' | `A'..'F' |\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1862
msgid "Draft Dart Programming Language Specification Draft 37"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1865
#: dartLangSpec.txt:3335
msgid "DIGIT ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1869
msgid "If a numeric literal begins with the prefix `0x' or `0X', it denotes the hexadecimal integer represented by the part of the literal following `0x' (respectively `0X'). Otherwise, if the numeric literal does not include a decimal point it denotes a decimal integer. Otherwise, the numeric literal denotes a 64 bit double precision floating point number as specified by the IEEE 754 standard."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1872
msgid "An integer literal or a literal double may optionally be prefixed by a plus sign (+). This has no semantic effect."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1876
msgid "There is no unary plus operator in Dart. However, we allow a leading plus in decimal numeric literals for clarity and to provide some compatibility with Javascript."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1880
msgid "Integers are not restricted to a fixed range. Dart integers are true integers, not 32 bit or 64 bit or any other fixed range representation. Their size is limited only by the memory available to the implementation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1885
msgid "It is a compile-time error for a class or interface to attempt to extend or implement int. It is a compile-time error for a class or interface to attempt to extend or implement double. It is a compile-time error for any type other than the types int and double to attempt to extend or implement num."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1889
msgid "An integer literal is either a hexadecimal integer literals or a decimal integer literal. The static type of an integer literal is int. A literal double is a numeric literal that is not an integer literal. The static type of a literal double is double."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1893
msgid "10.4 Booleans The reserved words true and false denote objects that represent the boolean values true and false respectively. They are the boolean literals."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1895
msgid "booleanLiteral:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1899
msgid "true | false ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1901
msgid "Both true and false implement the built-in interface bool. It is a compiletime error for a class or interface to attempt to extend or implement bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1904
msgid "It follows that the two boolean literals are the only two instances of bool.  The static type of a boolean literal is bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1907
msgid "10.4.1 Boolean Conversion Boolean conversion maps any object o into a boolean defined as"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1909
msgid "(bool v){"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1912
msgid "assert(v != null); return v === true;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1914
msgid "Draft Dart Programming Language Specification Draft 38"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1922
msgid "}(o)  Boolean conversion is used as part of control-flow constructs and boolean expressions. Ideally, one would simply insist that control-flow decisions be based exclusively on booleans. This is straightforward in a statically typed setting. In a dynamically typed language, it requires a dynamic check. Sophisticated virtual machines can minimize the penalty involved. Alas, Dart must be compiled into Javascript. Boolean conversion allows this to be done efficiently."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1929
msgid "At the same time, this formulation differs radically from Javascript, where most numbers and objects are interpreted as true. Darts approach prevents usages such if (a-b) ; because it does not agree with the low level conventions whereby non-null objects or non-zero numbers are treated as true. Indeed, there is no way to derive true from a non-boolean object via boolean conversion, so this kind of low level hackery is nipped in the bud."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1936
msgid "Dart also avoids the strange behaviors that can arise due to the interaction of boolean conversion with autoboxing in Javascript. A notorious example is the situation where false can be interpreted as true. In Javascript, booleans are not objects, and instead are autoboxed into objects where needed. If false gets autoboxed into an object, that object can be coerced into true (as it is a non-null object)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1939
msgid "10.5 Strings A string is a sequence of valid Unicode code points."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1941
msgid "stringLiteral:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1945
msgid "`@' ? MULTI LINE STRING | SINGLE LINE STRING ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1947
msgid "A string can be either a single line string or a multiline string."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1949
msgid "SINGLE LINE STRING:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1955
msgid "`\"' STRING CONTENT DQ* `\"' | `'' STRING CONTENT SQ* `\\'' | `@' `'' ( ( `'' | NEWLINE ))* `'' | `@' `\"' ( ( `\"' | NEWLINE ))* `\"' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1958
msgid "The grammar ensures that a single line string cannot span more than one line of source code, unless it includes an interpolated expression that spans multiple lines."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1961
msgid "A single line string is delimited by either matching single quotes or matching double quotes."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1965
msgid "Hence, `abc' and \"abc\" are both legal strings, as are `He said \"To be or not to be\" did he not?' and \"He said `To be or not to be' didn't he\". However \"This ` is not a valid string, nor is `this\".\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1967
msgid "Draft Dart Programming Language Specification Draft 39"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1969
msgid "MULTI LINE STRING:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1973
msgid "`\"\"\"' (~ `\"\"\"')* `\"\"\"' | `'''' (~ `'''')* `'''' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1975
msgid "ESCAPE SEQUENCE:\\"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1986
msgid "n |\\ r |\\ f |\\ b |\\ t |\\ v |\\ x HEX DIGIT HEX DIGIT |\\ u HEX DIGIT HEX DIGIT HEX DIGIT HEX DIGIT |\\ u{ HEX DIGIT SEQUENCE } ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1988
msgid "HEX DIGIT SEQUENCE:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1991
msgid "HEX DIGIT HEX DIGIT? HEX DIGIT? HEX DIGIT? HEX DIGIT? HEX DIGIT? HEX DIGIT?"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1996
msgid "Multiline strings are delimited by either matching triples of single quotes or matching triples of double quotes."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:1998
msgid "Strings support escape sequences for special characters. The escapes are:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2000
msgid ""
"\\n"
" for newline, equivalent to \\x0A."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2002
msgid "\\r for carriage return, equivalent to \\x0D."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2004
msgid "\\f for form feed, equivalent to \\x0C."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2006
msgid "\\b for backspace, equivalent to \\x08."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2008
msgid "\\t for tab, equivalent to \\x09."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2010
msgid "\\v for vertical tab, equivalent to \\x0B"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2012
msgid "\\x HEX DIGIT1 HEX DIGIT2, equivalent to \\u{HEX DIGIT1 HEX DIGIT2}."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2014
msgid "\\u HEX DIGIT1 HEX DIGIT2 HEX DIGIT3 HEX DIGIT4, equivalent to \\u{HEX DIGIT1 HEX DIGIT2 HEX DIGIT3 HEX DIGIT4}."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2016
msgid "\\u{HEX DIGIT SEQU EN CE} is the unicode scalar value represented"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2020
msgid "by the HEX DIGIT SEQU EN CE. It is a compile-time error if the value of the HEX DIGIT SEQU ENCE is not a valid unicode scalar value.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2022
msgid "Draft Dart Programming Language Specification Draft 40"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2024
msgid "$ indicating the beginning of an interpolated expression."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2029
#, no-wrap
msgid ""
"* Otherwise, \\k indicates the character k for any k not in {n, r, f, b, t, v, x, u}.\n"
"It is a compile-time error if a string literal contains a character sequence of\n"
"the form \\x that is not followed by a sequence of two hexadecimal digits. It is\n"
"a compile-time error if a string literal contains a character sequence of the form\\\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2032
msgid "u that is not followed by either a sequence of four hexadecimal digits, or by curly brace delimited sequence of hexadecimal digits."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2035
msgid "However, any string may be prefixed with the character @, indicating that it is a raw string, in which case no escapes are recognized."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2037
msgid "STRING CONTENT DQ:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2042
msgid "~( `\\' | `\"' | `$' | NEWLINE ) | `\\' ~( NEWLINE ) | STRING INTERPOLATION ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2044
msgid "STRING CONTENT SQ:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2049
msgid "~( `\\' | `'' | `$' | NEWLINE ) | `\\' ~( NEWLINE ) | STRING INTERPOLATION ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2051
msgid "NEWLINE:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2055
msgid "`\\ n' | `\\ r' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2058
msgid "All string literals implement the built-in interface String. It is a compiletime error for a class or interface to attempt to extend or implement String.  The static type of a string literal is String."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2064
msgid "10.5.1 String Interpolation It is possible to embed expressions within string literals, such that the these expressions are evaluated, and the resulting values are converted into strings and concatenated with the enclosing string. This process is known as string interpolation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2066
msgid "STRING INTERPOLATION:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2070
msgid "`$' IDENTIFIER NO DOLLAR | `$' `{' Expression `}' ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2072
msgid "Draft Dart Programming Language Specification Draft 41"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2075
msgid "The reader will note that the expression inside the interpolation could itself include strings, which could again be interpolated recursively."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2077
msgid "An unescaped $ character in a string signifies the beginning of an interpolated expression. The $ sign may be followed by either:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2079
msgid "A single identifier id that must not contain the $ character."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2085
#, no-wrap
msgid ""
"* An expression e delimited by curly braces.\n"
"The form $id is equivalent to the form ${id}. An interpolated string `s1${e}s2'\n"
"is equivalent to `s1' + e.toString() + `s2'. Likewise an interpolated string\n"
"\"s1${e}s2\" is equivalent to \"s1\" + e.toString() + \"s2\", assuming + is the string\n"
"concatenation operator.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2095
msgid "The string interpolation syntax is designed to be familiar and easy to use, if somewhat awkward to parse. The intent is to encourage its use over alternatives such as s1 + s2. In a dynamically typed language, the use of the + operator requires dynamic dispatch. In contrast, in the case of string interpolation we can statically determine that the string concatenation operation is required, making the operation more efficient. Even more importantly, it helps the system to determine if other uses of + are numeric, helping the implementation speed up those operations. This is especially crucial for a language that must be efficiently compiled into Javascript."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2098
msgid "10.6 Lists A list literal denotes a list, which is an integer indexed collection of objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2100
msgid "listLiteral:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2103
msgid "const? typeArguments? `[' (expressionList `, ' ?)? `]' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2109
msgid "A list may contain zero or more objects. The number of elements in a list is its size. A list has an associated set of indices. An empty list has an empty set of indices. A non-empty list has the index set {0 . . . n - 1} where n is the size of the list. It is a runtime error to attempt to access a list using an index that is not a member of its set of indices."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2113
msgid "If a list literal begins with the reserved word const, it is a constant list literal and it is computed at compile-time. Otherwise, it is a run-time list literal and it is evaluated at run-time."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2119
msgid "It is a compile-time error if an element of a constant list literal is not a compile-time constant. It is a compile-time error if the type argument of a constant list literal includes a type variable. The binding of a type variable is not known at compile-time, so we cannot use type variables inside compile-time constants."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2122
msgid "The value of a constant list literal const < E > [e1 . . . en] is an object a that implements the built-in interface List < E >. The ith element of a is\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2127
msgid "Draft Dart Programming Language Specification Draft 42 vi+1, where vi is the value of the compile-time expression ei. The value of a constant list literal const [e1 . . . en] is defined as the value of the constant list literal const< Dynamic > [e1 . . . en]."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2132
msgid "Let list1 = const < V > [e11 . . . e1n] and list2 = const < U > [e21 . . . e2n] be two constant list literals and let the elements of list1 and list2 evaluate to o11 . . . o1n and o21 . . . o2n respectively. Iff o1i === o2i for i 2 1..n and V = U then list1 === list2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2135
msgid "In other words, constant list literals are canonicalized.  A run-time list literal < E > [e1 . . . en] is evaluated as follows:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2137
msgid "First, the expressions e1 . . . en are evaluated in order they appear in the"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2139
msgid "program, yielding objects o1 . . . on."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2141
msgid "A fresh instance (7.5.1) a that implements the built-in interface List <"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2143
msgid "E > is allocated."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2145
msgid "The ith element of a is set to oi+1, 0 <= i <= n."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2152
#, no-wrap
msgid ""
"* The result of the evaluation is a.\n"
"Note that this document does not specify an order in which the elements are\n"
"set. This allows for parallel assignments into the list if an implementation so desires.\n"
"The order can only be observed in checked mode: if element i is not a subtype of\n"
"the element type of the list, a dynamic type error will occur when a[i] is assigned\n"
"oi-1.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2157
msgid "A runtime list literal [e1 . . . en] is evaluated as < Dynamic > [e1 . . . en].  There is no restriction precluding nesting of list literals. It follows from the rules above that < List < int >> [[1, 2, 3], [4, 5, 6]] is a list with type parameter List < int >, containing two lists with type parameter Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2161
msgid "The static type of a list literal of the form const< E > [e1 . . . en] or the form < E > [e1 . . . en] is List < E >. The static type a list literal of the form const [e1 . . . en] or the form [e1 . . . en] is List < Dynamic >."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2168
msgid "It is tempting to assume that the type of the list literal would be computed based on the types of its elements. However, for mutable lists this may be unwarranted. Even for constant lists, we found this behavior to be problematic. Since compile-time is often actually runtime, the runtime system must be able to perform a complex least upper bound computation to determine a reasonably precise type. It is better to leave this task to a tool in the IDE. It is also much more uniform (and therefore predictable and understandable) to insist that whenever types are unspecified they are assumed to be the unknown type Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2171
msgid "10.7 Maps A map literal denotes a map from strings to objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2173
msgid "mapLiteral:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2175
msgid "const? typeArguments? `{' (mapLiteralEntry (`, ' mapLiteralEntry)* `, ' ?)? `}'\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2177
msgid "Draft Dart Programming Language Specification Draft 43"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2180
msgid "; mapLiteralEntry:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2184
msgid "identifier `:' expression | stringLiteral `:' expression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2187
msgid "A map literal consists of zero or more entries. Each entry has a key, which is a string literal, and a value, which is an object."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2191
msgid "If a map literal begins with the reserved word const, it is a constant map literal and it is computed at compile-time. Otherwise, it is a run-time map literal and it is evaluated at run-time."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2195
msgid "It is a compile-time error if either a key or a value of an entry in a constant map literal is not a compile-time constant. It is a compile-time error if the type argument of a constant map literal includes a type variable."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2202
msgid "The value of a constant map literal const< V > {k1 : e1 . . . kn : en} is an object m that implements the built-in interface M ap < String, V >. The entries of m are ui : vi, i 2 1..n, where ui is the value of the compile-time expression ki and vi is the value of the compile-time expression ei. The value of a constant map literal const {k1 : e1 . . . kn : en} is defined as the value of a constant map literal const < Dynamic > {k1 : e1 . . . kn : en}."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2205
msgid "As specified, a typed map literal takes only one type parameter. If we generalize literal maps so they can have keys that are not strings, we would need two parameters. The implementation currently insists on two type parameters."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2211
msgid "Let map1 = const< V > {k11 : e11 . . . k1n : e1n} and map2 = const< U >{ k21 : e21 . . . k2n : e2n} be two constant map literals. Let the keys of map1 and map2 evaluate to s11 . . . s1n and s21 . . . s2n respectively, and let the elements of map1 and map2 evaluate to o11 . . . o1n and o21 . . . o2n respectively. Iff o1i === o2i and s1i === s2i for i 2 1..n, and V = U then map1 === map2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2214
msgid "In other words, constant map literals are canonicalized.  A runtime map literal < V > {k1 : e1 . . . kn : en} is evaluated as follows:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2216
msgid "First, the expressions e1 . . . en are evaluated in left to right order, yielding"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2218
msgid "objects o1 . . . on."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2220
msgid "A fresh instance (7.5.1) m that implements the built-in interface Map <"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2222
msgid "String, V > is allocated."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2224
msgid "Let ui be the value of the compile-time constant string specified by ki. An"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2226
msgid "entry with key ui and value oi is added to m, 0 <= i <= n."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2230
#, no-wrap
msgid ""
"* The result of the evaluation is m.\n"
"A runtime map literal {k1 : e1 . . . kn : en} is evaluated as < Dynamic >{\n"
"k1 : e1 . . . kn : en}.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2232
msgid "It is a static warning if the values of any two keys in a map literal are equal.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2234
msgid "Draft Dart Programming Language Specification Draft 44"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2237
msgid "A map literal is ordered: iterating over the keys and/or values of the maps always happens in the order the keys appeared in the source code."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2240
msgid "Of course, if a key repeats, the order is defined by first occurrence, but the value is defined by the last."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2245
msgid "The static type of a map literal of the form const< V > {k1 : e1 . . . kn : en} or the form < V > {k1 : e1 . . . kn : en} is M ap < String, V >. The static type a map literal of the form const{k1 : e1 . . . kn : en} or the form {k1 : e1 . . . kn : en} is Map < String, Dynamic >."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2248
msgid "10.8 Function Expressions A function literal is an object that encapsulates an executable unit of code."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2250
msgid "functionExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2252
msgid "(returnType? identifier)? formalParameterList functionExpressionBody"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2256
msgid "functionExpressionBody:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2260
msgid "`=>' expression | block ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2267
msgid "A function literal implements the built-in interface Function.  The static type of a function literal of the form (T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]) => e or of the form id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]) => e is (T1 . . . , Tn, [Tn+1 xn+1, . . . , Tn+k xn+k]) ! T0, where T0 is the static type of e. In any case where Ti, 1 <= i <= n+k, is not specified, it is considered to have been specified as Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2273
msgid "The static type of a function literal of the form T0 id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){s} or of the form T0 id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]) => e is (T1 . . . , Tn, [Tn+1 xn+1, . . . , Tn+k xn+k]) ! T0. In any case where Ti, 1 <= i <= n + k, is not specified, it is considered to have been specified as Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2279
msgid "The static type of a function literal of the form id(T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){s} or of the form (T1 a1, . . . , Tn an, [Tn+1 xn+1 = d1, . . . , Tn+k xn+k = dk]){s} is (T1 . . . , Tn, [Tn+1 xn+1, . . . , Tn+k xn+k]) ! Dynamic. In any case where Ti, 1 <= i <= n + k, is not specified, it is considered to have been specified as Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2282
msgid "10.9 This The reserved word this denotes the target of the current instance member invocation.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2284
msgid "Draft Dart Programming Language Specification Draft 45"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2286
msgid "thisExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2289
msgid "this ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2294
msgid "The static type of this is the interface of the immediately enclosing class.  We do not support self-types at this point.  It is a compile-time error if this appears in a top-level function or variable initializer, in a factory constructor, or in a static method or variable initializer."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2297
msgid "10.10 Instance Creation Instance creation expressions invoke constructors to produce instances."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2307
msgid "It is a static warning to instantiate an abstract class (7.1.1).  It is a compile-time error if any of the type arguments to a constructor of a generic type invoked by a new expression or a constant object expression do not denote types in the enclosing lexical scope. It is a compile-time error if a constructor of a non-generic type invoked by a new expression or a constant object expression is passed any type arguments. It is a compile-time error if a constructor of a generic type with n type parameters invoked by a new expression or a constant object expression is passed m type arguments where m 6= n."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2311
msgid "It is a static type warning if any of the type arguments to a constructor of a generic type G invoked by a new expression or a constant object expression are not subtypes of the bounds of the corresponding formal type parameters of G."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2316
msgid "Let I be an interface type (8)with default factory (8.3) F . It is a static type warning if any of the type arguments to the constructor of I invoked by a new expression or a constant object expression are not subtypes of the bounds of the corresponding formal type parameters of F ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2319
msgid "10.10.1 New The new expression invokes a constructor (7.5)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2321
msgid "newExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2324
msgid "new type (`.' identifier)? arguments ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2329
msgid "Let e be a new expression of the form new T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) or the form new T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k). It is a compile-time error if T is not a class or interface accessible in the current scope, optionally followed by type arguments."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2333
msgid "If e of the form new T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) it is a compile-time error if T.id is not the name of a constructor declared by the type T . If e of the form new T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) it is a\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2337
msgid "Draft Dart Programming Language Specification Draft 46 compile-time error if the type T does not declare a constructor with the same name as the declaration of T ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2347
msgid "If T is a parameterized type (13.8) S < U1, . . . , Um >, let R = S. It is a compile-time error if S is not a generic (9) type with m type parameters. If T is not a parameterized type, let R = T . If R is an interface, let C be the factory class (8.3) of R. Otherwise let C = R. Furthermore, if e is of the form new T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) then let q be the constructor of C that corresponds (8.3) to the constructor T.id, otherwise let q be the constructor of C that corresponds to the constructor T . Finally, if C is generic but T is not a parameterized type, then for i 2 1..m, let Vi = Dynamic, otherwise let Vi = Ui."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2353
msgid "Evaluation of e proceeds as follows: First, if q is a generative constructor (7.5.1), then: If R 6= C then let Wi be the type parameters of R (if any) and let Di be the bound of Wi, 1 <= i <= m. In checked mode, it is a dynamic type error if Vi is not a subtype of [V1, . . . , Vm/W1, . . . , Wm]Di, i 2 1..m."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2357
msgid "Regardless of whether R 6= C, let Ti be the type parameters of C (if any)  and let Bi be the bound of Ti, 1 <= i <= m. In checked mode, it is a dynamic type error if Vi is not a subtype of [V1, . . . , Vm/T1, . . . , Tm]Bi, i 2 1..m."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2362
msgid "A fresh instance (7.5.1), i, of class C is allocated. For each instance variable f of i, if the variable declaration of f has an initializer, then f is bound to that value (which is necessarily a compile-time constant). Otherwise f is bound to null."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2369
msgid "Next, the argument list (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated. Then, the initializer list of q is executed with respect to the bindings that resulted from the evaluation of the argument list, and with this bound to i and the type parameters (if any) of C bound to the actual type arguments V1, . . . , Vm. Finally, the body of q is executed with respect to the bindings that resulted from the evaluation of the argument list. The result of the evaluation of e is i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2376
msgid "Otherwise, if q is a redirecting constructor (7.5.1), then: The argument list (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated. Then, the redirect clause of q is executed with respect to the bindings that resulted from the evaluation of the argument list and the type parameters (if any) of C bound to the actual type arguments V1, . . . , Vm resulting in an object i that is necessarily the result of another constructor call. The result of the evaluation of e is i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2381
msgid "Otherwise, q is a factory constructor (7.5.2). Then: If R 6= C then let Wi be the type parameters of R (if any) and let Di be the bound of Wi, 1 <= i <= m. In checked mode, it is a dynamic type error if Vi is not a subtype of [V1, . . . , Vm/W1, . . . , Wm]Di, i 2 1..m."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2388
msgid "Regardless of whether R 6= C, let Ti be the type parameters of C (if any)  and let Bi be the bound of Ti, 1 <= i <= m. In checked mode, it is a dynamic type error if Vi is not a subtype of [V1, . . . , Vm/T1, . . . , Tm]Bi, i 2 1..m. The argument list (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated. Then, the body of q is executed with respect to the bindings that resulted from the evaluation of the argument list and the type parameters (if any) of q bound to\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2392
msgid "Draft Dart Programming Language Specification Draft 47 the actual type arguments V1, . . . , Vm resulting in an object i. The result of the evaluation of e is i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2398
msgid "The static type of a new expression of either the form new T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) or the form new T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is T . It is a static warning if the static type of ai, 1 <= i <= n+k may not be assigned to the type of the corresponding formal parameter of the constructor T.id (respectively T )."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2401
msgid "10.10.2 Const A constant object expression invokes a constant constructor (7.5.3)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2403
msgid "constObjectExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2406
msgid "const type ('.' identifier)? arguments ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2412
msgid "Let e be a constant object expression of the form const T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) or the form const T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k). It is a compile-time error if T is not a class or interface accessible in the current scope, optionally followed by type arguments. It is a compile-time error if T includes any type variables."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2418
msgid "If e of the form const T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) it is a compile-time error if T.id is not the name of a constant constructor declared by the type T . If e of the form const T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)  it is a compile-time error if the type T does not declare a constant constructor with the same name as the declaration of T ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2421
msgid "In all of the above cases, it is a compile-time error if ai, i 2 1..n + k, is not a compile-time constant expression."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2428
msgid "If T is a parameterized type (13.8) S < U1, . . . , Um >, let R = S. It is a compile-time error if S is not a generic (9) type with m type parameters. If T is not a parameterized type, let R = T . If R is an interface, let C be the factory class (8.3) of R. Otherwise let C = R. Finally, if C is generic but T is not a parameterized type, then for all i 2 1..m, let Vi = Dynamic, otherwise let Vi = Ui."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2435
msgid "Evaluation of e proceeds as follows: First, if e is of the form const T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) then let i be the value of the expression new T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k). Otherwise, e must be of the form const T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k), in which case let i be the result of evaluating new T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k). Then:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2438
#, no-wrap
msgid ""
"* If during execution of the program, a constant object expression has already evaluated to an instance j of class C with type arguments Vi, 1 <=\n"
"i <= m, then:\f\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2440
msgid "Draft Dart Programming Language Specification Draft 48"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2442
msgid "- For each instance variable f of i, let vif be the value of the f in i,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2445
msgid "and let vjf be the value of the field f in j. If vif === vjf for all fields f in i, then the value of e is j, otherwise the value of e is i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2454
#, no-wrap
msgid ""
"* Otherwise the value of e is i.\n"
"In other words, constant objects are canonicalized. In order to determine if an\n"
"object is actually new, one has to compute it; then it can be compared to any\n"
"cached instances. If an equivalent object exists in the cache, we throw away the\n"
"newly created object and use the cached one. Objects are equivalent if they have\n"
"identical fields and identical type arguments. Since the constructor cannot induce\n"
"any side effects, the execution of the constructor is unobservable. The constructor\n"
"need only be executed once per call site, at compile-time.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2460
msgid "The static type of a constant object expression of either the form const T.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) or the form const T (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is T . It is a static warning if the static type of ai, 1 <= i <= n + k may not be assigned to the type of the corresponding formal parameter of the constructor T.id (respectively T )."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2463
msgid "It is a compile-time error if evaluation of a constant object results in an uncaught exception being thrown."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2466
msgid "To see how such situations might arise, consider the following examples: class A {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2469
msgid "final var x; const A(var p): x = p * 10;}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2473
msgid "const A(\"x\"); // compile-time error const A(5); // legal class IntPair {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2477
msgid "const IntPair(this.x, this.y); final int x; final int y;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2479
msgid "operator *(v) => new IntPair(x*v, y*v);}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2484
msgid "const A(const IntPair(1,2)); // compile-time error: illegal in a subtler way Due to the rules governing constant constructors, evaluating the constructor A() with the argument \"x\" or the argument const IntPair(1, 2) would cause it to throw an exception, resulting in a compile-time error."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2490
msgid "10.11 Spawning an Isolate Spawning an isolate is accomplished via what is syntactically an ordinary library call, invoking the instance method spawn() defined in class Isolate. However, such calls have the semantic effect of creating a new isolate with its own memory and thread of control.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2497
msgid "Draft Dart Programming Language Specification Draft 49 10.12 Property Extraction Property extraction allows for a member of an object to be concisely extracted from the object. If o is an object, and if m is the name of a method member of o, then o.m is defined to be equivalent to (r1, . . . , rn, [p1 = d1, . . . , pk = dk]){return o.m(r1, . . . , rn, p1, . . . , pk); } if m has required parameters r1, . . . , rn, and named parameters p1, . . . , pk with defaults d1, . . . , dk."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2500
msgid "Otherwise, if m is the name of a getter (7.2) member of o (declared implicitly or explicitly) then o.m evaluates to the result of invoking the getter."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2502
msgid "Observations:"
msgstr ""

#. type: Bullet: '1. '
#: dartLangSpec.txt:2505
msgid "One cannot extract a getter or a setter."
msgstr ""

#. type: Bullet: '2. '
#: dartLangSpec.txt:2505
msgid "One can tell whether one implemented a property via a method or via field/getter,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2508
msgid "which means that one has to plan ahead as to what construct to use, and that choice is reflected in the interface of the class."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2518
msgid "10.13 Function Invocation Function invocation occurs in the following cases: when a function expression (10.8) is invoked (10.13.4), when a method is invoked (10.14) or when a constructor is invoked (either via instance creation (10.10), constructor redirection (7.5.1) or super initialization). The various kinds of function invocation differ as to how the function to be invoked, f , is determined, as well as whether this is bound. Once f has been determined, the formal parameters of f are bound to corresponding actual arguments. The body of f is then executed with the aforementioned bindings. Execution of the body terminates when the first of the following occurs:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2520
msgid "An uncaught exception is thrown."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2522
msgid "A return statement (11.10) immediately nested in the body of f is executed."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2524
msgid "The last statement of the body completes execution."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2528
msgid "10.13.1 Actual Argument List Evaluation Function invocation involves evaluation of the list of actual arguments to the function and binding of the results to the functions formal parameters."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2530
msgid "arguments:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2533
msgid "`(' argumentList? `)' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2535
msgid "argumentList:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2538
msgid "namedArgument (`, ' namedArgument)* | expressionList (`, ' namedArgument)*\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2540
msgid "Draft Dart Programming Language Specification Draft 50"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2543
msgid "; namedArgument:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2546
msgid "label expression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2549
msgid "Evaluation of an actual argument list of the form (a1, . . . , am, q1 : am+1, . . . , ql : am+l) proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2552
msgid "The arguments a1, . . . , am+l are evaluated in the order they appear in the program, yielding objects o1, . . . , om+l."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2555
msgid "Simply stated, an argument list consisting of m positional arguments and l named arguments is evaluated from left to right."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2559
msgid "10.13.2 Binding Actuals to Formals Let f be a function, let p1 . . . pn be the positional parameters of f and let pn+1, . . . , pn+k be the named parameters declared by f."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2562
msgid "An evaluated actual argument list o1 . . . om+l derived from an actual argument list of the form (a1, . . . , am, q1 : am+1, . . . , ql : am+l) is bound to the formal parameters of f as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2571
msgid "Again, we have an argument list consisting of m positional arguments and l named arguments. We have a function with n required parameters and k named parameters. The number of positional arguments must be at least as large as the number of required parameters. All named arguments must have a corresponding named parameter. You may not provide the same parameter as both a positional and a named argument. If an optional parameter has no corresponding argument, it gets its default value. In checked mode, all arguments must belong to subtypes of the type of their corresponding formal."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2576
msgid "If m < n, or m > n + k, a run-time error occurs. Furthermore, each qi, 1 <= i <= l, must be a member of the set {pm+1, . . . , pm+k} or a run time error occurs. Then pi is bound to oi, i 2 1..m, and qj is bound to om+j, j 2 1..l. All remaining formal parameters of f are bound to their default values."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2579
msgid "All of these remaining parameters are necessarily optional and thus have default values."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2584
msgid "In checked mode, it is a dynamic type error if oi is not null and the actual type (13.8.1) of pi is not a supertype of the type of oi, i 2 1..m. In checked mode, it is a dynamic type error if om+j is not null and the actual type (13.8.1)  of qj is not a supertype of the type of om+j, j 2 1..l."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2586
msgid "It is a compile-time error if qi = qj for any i 6= j."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2590
msgid "10.13.3 Unqualified Invocation An unqualified function invocation i has the form id(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k), where id is an identifier."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2592
msgid "If there exists a lexically visible declaration named id, let fid be the innermost such declaration. Then:\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2594
msgid "Draft Dart Programming Language Specification Draft 51"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2596
msgid "If fid is a local function, a library function, a library or static getter or a"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2598
msgid "variable then i is interpreted as a function expression invocation (10.13.4)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2601
#, no-wrap
msgid ""
"* Otherwise, if fid is a static method of the enclosing class C, i is equivalent the static method invocation C.id(a1, . . . , an, xn+1 : an+1, . . . , xn+k :\n"
"an+k).\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2604
msgid "Otherwise, i is equivalent to the ordinary method invocation this.id((a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2610
msgid "10.13.4 Function Expression Invocation A function expression invocation i has the form ef (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k), where ef is an expression. If ef is an identifier id, then id must necessarily denote a local function, a library function, a library or static getter or a variable as described above, or i is not considered a function expression invocation. If ef is a property access expression, then i is treated as an ordinary method invocation (10.14.1). Otherwise:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2614
msgid "A function expression invocation ef (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)  is equivalent to the ordinary method invocation ef .call(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2618
msgid "It is a static warning if the static type F of ef may not be assigned to a function type. If F is not a function type, the static type of i is Dynamic.  Otherwise:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2620
#: dartLangSpec.txt:2678
#: dartLangSpec.txt:2709
#: dartLangSpec.txt:2752
msgid "the static type of i is the declared return type of F ."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:2622
#: dartLangSpec.txt:2680
#: dartLangSpec.txt:2711
#: dartLangSpec.txt:2754
msgid "Let Ti be the static type of ai, i 2 1..n + k. It is a static warning if F is"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2624
#: dartLangSpec.txt:2682
#: dartLangSpec.txt:2713
msgid "not a supertype of (T1, . . . , Tn, [Tn+1 xn+1, . . . , Tn+k xn+k]) ! ?."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2627
msgid "10.14 Method Invocation Method invocation can take several forms as specified below."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2631
msgid "10.14.1 Ordinary Invocation An ordinary method invocation i has the form o.m(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2635
msgid "The result of a lookup of a method m in object o with respect to library L is the result of a lookup of method m in class C with respect to library L, where C is the class of o."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2641
msgid "The result of a lookup of method m in class C with respect to library L is: If C declares an instance method named m that is accessible to L, then that method is the result of the lookup. Otherwise, if C has a superclass S, then the result of the lookup is the result of looking up m in S with respect to L.  Otherwise, we say that the method lookup has failed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2644
msgid "Evaluation of an ordinary method invocation i of the form o.m(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) proceeds as follows:\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2646
msgid "Draft Dart Programming Language Specification Draft 52"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2654
msgid "First, the expression o is evaluated to a value vo. Next, the argument list (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated yielding actual argument objects o1, . . . , on+k. Let f be the result of looking up method m in vo with respect to the current library L. If the method lookup succeeded, the body of f is executed with respect to the bindings that resulted from the evaluation of the argument list, and with this bound to vo. The value of i is the value returned after f is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2659
msgid "If the method lookup has failed, then let g be the result of looking up getter m in vo with respect to L. If the getter lookup succeeded, let vg be the value of the getter invocation o.m. Then let c be the result of looking up method call in vg with respect to the current library L."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2662
#: dartLangSpec.txt:2735
msgid "Next, c is executed with respect to the bindings of the evaluated argument list. The value of i is the value returned after c is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2667
msgid "If the getter lookup has also failed, then a new instance im of the predefined interface InvocationMirror is created by calling its factory constructor with arguments m, this, [o1, . . . , on] and {xn+1 : on+1, . . . , xn+k : on+k}. Then the method noSuchMethod() is looked up in o and invoked with argument im, and the result of this invocation is the result of evaluating i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2670
msgid "Notice that the wording carefully avoids re-evaluating the receiver o and the arguments ai."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2676
msgid "Let T be the static type of o. It is a static type warning if T does not have an accessible (3.2) instance member named m. If T.m exists, it is a static type warning if the type F of T.m may not be assigned to a function type. If T.m does not exist, or if F is not a function type, the static type of i is Dynamic; otherwise:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2686
msgid "10.14.2 Static Invocation A static method invocation i has the form C.m(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2689
msgid "It is a compile-time error if C does not denote a class in the current scope.  It is a compile-time error if C does not declare a static method or getter m."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2691
msgid "Note the requirement that C declare the method. This means that static methods declared in superclasses of C cannot be invoked via C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2695
msgid "Evaluation of i proceeds as follows: First, if the member m declared by C is a getter, then i is equivalent to the expression C.m.call(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2697
msgid "Otherwise, let f be the the method m declared in class C. Next, the argument list(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2701
msgid "The body of f is then executed with respect to the bindings that resulted from the evaluation of the argument list. The value of i is the value returned after the body of f is executed.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2703
msgid "Draft Dart Programming Language Specification Draft 53"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2707
msgid "It is a static type warning if the type F of C.m may not be assigned to a function type. If F is not a function type, the static type of i is Dynamic.  Otherwise:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2716
msgid "10.14.3 Super Invocation A super method invocation has the form"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2727
msgid "super.m(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k).  Evaluation of a super method invocation i of the form super.m(a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k)  proceeds as follows: First, the argument list (a1, . . . , an, xn+1 : an+1, . . . , xn+k : an+k) is evaluated yielding actual argument objects o1, . . . , on+k. Let S be the superclass of the class of this, and let f be the result of looking up method m in S with respect to the current library L. If the method lookup succeeded, the body of f is executed with respect to the bindings that resulted from the evaluation of the argument list, and with this bound to the current value of this. The value of i is the value returned after f is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2732
msgid "If the method lookup has failed, then let g be the result of looking up getter m in vo with respect to L. If the getter lookup succeeded, let vg be the value of the getter invocation super.m. Then let c be the result of looking up method call in vg with respect to the current library L."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2740
msgid "If getter lookup has also failed, then a new instance im of the predefined interface InvocationMirror is created by calling its factory constructor with arguments m, this, [o1, . . . , on] and {xn+1 : on+1, . . . , xn+k : on+k}. Then the method noSuchMethod() is looked up in S and invoked with argument im, and the result of this invocation is the result of evaluating i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2745
msgid "It is a compile-time error if a super method invocation occurs in a top-level function or variable initializer, in class Object, in a factory constructor, in an instance variable initializer, a constructor initializer or in a static method or variable initializer."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2750
msgid "It is a static type warning if S does not have an accessible (3.2) instance member named m. If S.m exists, it is a static type warning if the type F of S.m may not be assigned to a function type. If S.m does not exist, or if F is not a function type, the static type of i is Dynamic; otherwise:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2756
msgid "not a supertype of (T1, . . . , tn, [Tn+1 xn+1, . . . , Tn+k xn+k]) ! ?.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2762
msgid "Draft Dart Programming Language Specification Draft 54 10.14.4 Sending Messages Messages are the sole means of communication among isolates. Messages are sent by invoking specific methods in the Dart libraries; there is no specific syntax for sending a message."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2766
msgid "In other words, the methods supporting sending messages embody primitives of Dart that are not accessible to ordinary code, much like the methods that spawn isolates."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2769
msgid "10.15 Getter Invocation A getter invocation provides access to the value of a property."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2773
msgid "The result of a lookup of a getter (respectively setter) m in object o with respect to library L is the result of looking up getter (respectively setter) m in class C with respect to L, where C is the class of o."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2780
msgid "The result of a lookup of a getter (respectively setter) m in class C with respect to library L is: If C declares an instance getter (respectively setter)  named m that is accessible to L, then that getter (respectively setter) is the result of the lookup. Otherwise, if C has a superclass S, then the result of the lookup is the result of looking up getter (respectively setter) m in S with respect to L. Otherwise, we say that the lookup has failed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2786
msgid "Evaluation of a getter invocation i of the form e.m proceeds as follows: First, the expression e is evaluated to an object o. Then, the getter function (7.2) m is looked up in o with respect to the current library, and its body is executed with this bound to o. The value of the getter invocation expression is the result returned by the call to the getter function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2791
msgid "If the getter lookup has failed, then a new instance im of the predefined interface InvocationMirror is created by calling its factory constructor with arguments `get m`, this, [] and {}. Then the method noSuchMethod() is looked up in o and invoked with argument im, and the result of this invocation is the result of evaluating i."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2795
msgid "Let T be the static type of e. It is a static type warning if T does not have a getter named m. The static type of i is the declared return type of T.m, if T.m exists; otherwise the static type of i is Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2799
msgid "Evaluation of a getter invocation i of the form C.m proceeds as follows: The getter function C.m is invoked. The value of i is the result returned by the call to the getter function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2803
msgid "It is a compile-time error if there is no class C in the enclosing lexical scope of i, or if C does not declare, implicitly or explicitly, a getter named m. The static type of i is the declared return type of C.m."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2806
msgid "Evaluation of a top-level getter invocation i of the form m, where m is an identifier, proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2809
msgid "The getter function m is invoked. The value of i is the result returned by the call to the getter function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2811
msgid "The static type of i is the declared return type of m.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2815
msgid "Draft Dart Programming Language Specification Draft 55 10.16 Assignment An assignment changes the value associated with a mutable variable or property."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2817
msgid "assignmentOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2821
msgid "`=' | compoundAssignmentOperator ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2826
msgid "Evaluation of an assignment of the form v = e proceeds as follows: If there is no declaration d with name v in the lexical scope enclosing the assignment, then the assignment is equivalent to the assignment this.v = e.  Otherwise, let d be the innermost declaration whose name is v, if it exists."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2829
msgid "If d is the declaration of a local or library variable, the expression e is evaluated to an object o. Then, the variable v is bound to o. The value of the assignment expression is o."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2832
msgid "Otherwise, if d is the declaration of a static variable in class C, then the assignment is equivalent to the assignment C.v = e."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2836
msgid "Otherwise, the assignment is equivalent to the assignment this.v = e.  In checked mode, it is a dynamic type error if o is not null and the interface induced by the class of o is not a subtype of the actual type (13.8.1) of v."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2839
msgid "It is a static type warning if the static type of e may not be assigned to the static type of v."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2844
msgid "Evaluation of an assignment of the form C.v = e proceeds as follows: The expression e is evaluated to an object o. Then, the setter C.v is invoked with its formal parameter bound to o. The value of the assignment expression is o."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2849
msgid "It is a compile-time error if there is no class C in the enclosing lexical scope of assignment, or if C does not declare, implicitly or explicitly, a setter v. In checked mode, it is a dynamic type error if o is not null and the interface induced by the class of o is not a subtype of the static type of C.v."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2852
msgid "It is a static type warning if the static type of e may not be assigned to the static type of C.v."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2858
msgid "Evaluation of an assignment of the form e1.v = e2 proceeds as follows: The expression e1 is evaluated to an object o1. Then, the expression e2 is evaluated to an object o2. Then, the setter v is looked up in o1 with respect to the current library, and its body is executed with its formal parameter bound to o2 and this bound to o1."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2863
msgid "If the setter lookup has failed, then a new instance im of the predefined interface InvocationMirror is created by calling its factory constructor with arguments `set v`, o1, [o2] and {}. Then the method noSuchMethod() is looked up in o1 and invoked with argument im. The value of the assignment expression is o2 irrespective of whether setter lookup has failed or succeeded."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2866
msgid "In checked mode, it is a dynamic type error if o2 is not null and the interface induced by the class of o2 is not a subtype of the actual type of e1.v.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2868
msgid "Draft Dart Programming Language Specification Draft 56"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2871
msgid "It is a static type warning if the static type of e2 may not be assigned to the static type of e1.v."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2874
msgid "Evaluation of an assignment of the form e1[e2] = e3 is equivalent to the evaluation of the expression (a, i, e){a.[]=(i, e); return e; } (e1, e2, e3)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2882
msgid "10.16.1 Compound Assignment A compound assignment of the form v op =e is equivalent to v=v op e. A compound assignment of the form C.v op=e is equivalent to C.v=C.v op e. A compound assignment of the form e1.v op = e2 is equivalent to ((x) => x.v = x.v op e2)(e1) where x is a variable that is not used in e2. A compound assignment of the form e1[e2] op=e3 is equivalent to ((a, i) => a[i] = a[i] op e3)(e1, e2) where a and i are a variables that are not used in e3."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2884
msgid "compoundAssignmentOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2897
msgid "`*=' | `/=' | `~/=' | `%=' | `+=' | `-=' | `<<=' | `>>=' | `&=' | `^=' | `|=' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2901
msgid "10.17 Conditional A conditional expression evaluates one of two expressions based on a boolean condition."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2903
msgid "conditionalExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2906
msgid "logicalOrExpression (`?' expression `:' expression)? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2909
msgid "Evaluation of a conditional expression c of the form e1?e2 : e3 proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2915
msgid "First, e1 is evaluated to an object o1. In checked mode, it is a dynamic type error if o1 is not of type bool. Otherwise, o1 is then subjected to boolean conversion (10.4.1) producing an object r. If r is true, then the value of c is the result of evaluating the expression e2. Otherwise the value of c is the result of evaluating the expression e3.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2917
msgid "Draft Dart Programming Language Specification Draft 57"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2921
msgid "It is a static type warning if the type of e1 may not be assigned to bool. The static type of c is the least upper bound (13.8.2) of the static type of e2 and the static type of e3."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2924
msgid "10.18 Logical Boolean Expressions The logical boolean expressions combine boolean objects using the boolean conjunction and disjunction operators."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2926
msgid "logicalOrExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2929
msgid "logicalAndExpression (`||' logicalAndExpression)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2931
msgid "logicalAndExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2934
msgid "bitwiseOrExpression (`&&' bitwiseOrExpression)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2937
msgid "A logical boolean expression is either a bitwise expression (10.19), or an invocation of a logical boolean operator on an expression e1 with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2941
msgid "Evaluation of a logical boolean expression b of the form e1||e2 causes the evaluation of e1; if e1 evaluates to true, the result of evaluating b is true, otherwise e2 is evaluated to an object o, which is then subjected to boolean conversion (10.4.1) producing an object r, which is the value of b."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2946
msgid "Evaluation of a logical boolean expression b of the form e1&&e2 causes the evaluation of e1; if e1 does not evaluate to true, the result of evaluating b is false, otherwise e2 is evaluated to an object o, which is then subjected to boolean conversion producing an object r, which is the value of b."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2948
msgid "The static type of a logical boolean expression is bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2951
msgid "10.19 Bitwise Expressions Bitwise expressions invoke the bitwise operators on objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2953
msgid "bitwiseOrExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2957
msgid "bitwiseXorExpression (`|' bitwiseXorExpression)* | super (`|' bitwiseXorExpression)+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2959
msgid "bitwiseXorExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2963
msgid "bitwiseAndExpression (`^' bitwiseAndExpression)* | super (`^' bitwiseAndExpression)+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2965
msgid "bitwiseAndExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2967
msgid "equalityExpression (`&' equalityExpression)* |\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2969
msgid "Draft Dart Programming Language Specification Draft 58"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2972
msgid "super (`&' equalityExpression)+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2974
msgid "bitwiseOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2979
msgid "`&' | `^' | `|' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2982
msgid "A bitwise expression is either an equality expression (10.20), or an invocation of a bitwise operator on either super or an expression e1, with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2985
msgid "A bitwise expression of the form e1 op e2 is equivalent to the method invocation e1.op(e2). A bitwise expression of the form super op e2 is equivalent to the method invocation super.op(e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2990
msgid "It should be obvious that the static type rules for these expressions are defined by the equivalence above - ergo, by the type rules for method invocation and the signatures of the operators on the type e1. The same holds in similar situations throughout this specification."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2993
msgid "10.20 Equality Equality expressions test objects for identity or equality."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2995
msgid "equalityExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:2999
msgid "relationalExpression (equalityOperator relationalExpression)? | super equalityOperator relationalExpression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3001
msgid "equalityOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3007
msgid "`==' | `!=' | `===' | `!==' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3010
msgid "An equality expression is either a relational expression (10.21), or an invocation of a equality operator on either super or an expression e1, with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3013
msgid "An equality expression of the form e1 == e2 is equivalent to the method invocation e1.==(e2). An equality expression of the form super == e is equivalent to the method invocation super.==(e)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3017
msgid "An equality expression of the form e1 != e2 is equivalent to the expression !(e1 == e2). An equality expression of the form super != e is equivalent to the expression !(super == e).\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3019
msgid "Draft Dart Programming Language Specification Draft 59"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3022
msgid "Evaluation of an equality expression ee of the form e1 === e2 proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3026
msgid "The expression e1 is evaluated to an object o1; then the expression e2 is evaluated to an object o2. Next, if o1 and o2 are the same object, then ee evaluates to true, otherwise ee evaluates to false."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3029
msgid "An equality expression of the form super === e is equivalent to the expression this === e. An equality expression of the form super !== e is equivalent to the expression !(super === e)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3032
msgid "An equality expression of the form e1 !== e2 is equivalent to the expression !(e1 === e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3038
msgid "The static type of an equality expression of the form e1 === e2 is bool.  The static types of other equality expressions follow from the definitions above.  The forms e1 != e2, e1 !== e2 and super != e are negations and have static type bool. The expression e1 == e2 is typed as a method invocation so its static type depends on the operator method declaration. It had better be bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3041
msgid "10.21 Relational Expressions Relational expressions invoke the relational operators on objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3043
msgid "relationalExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3045
msgid "shiftExpression (isOperator type | relationalOperator shiftExpression)? |"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3048
msgid "super relationalOperator shiftExpression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3050
msgid "relationalOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3056
msgid "`>=' | `>' | `<=' | `<' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3059
msgid "A relational expression is either a shift expression (10.22), or an invocation of a relational operator on either super or an expression e1, with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3062
msgid "A relational expression of the form e1 op e2 is equivalent to the method invocation e1.op(e2). A relational expression of the form super op e2 is equivalent to the method invocation super.op(e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3065
msgid "10.22 Shift Shift expressions invoke the shift operators on objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3067
msgid "shiftExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3069
msgid "additiveExpression (shiftOperator additiveExpression)* |\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3071
msgid "Draft Dart Programming Language Specification Draft 60"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3074
msgid "super (shiftOperator additiveExpression)+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3076
msgid "shiftOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3080
msgid "`<<' | `>>' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3083
msgid "A shift expression is either an additive expression (10.23), or an invocation of a shift operator on either super or an expression e1, with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3087
msgid "A shift expression of the form e1 op e2 is equivalent to the method invocation e1.op(e2). A shift expression of the form super op e2 is equivalent to the method invocation super.op(e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3089
msgid "Note that this definition implies left-to-right evaluation order among shift expressions:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3093
msgid "e1 << e2 << e3 is evaluated as (e1 << e2). << (e3) which is equivalent to (e1 << e2) << e3.  The same holds for additive and multiplicative expressions."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3096
msgid "10.23 Additive Expressions Additive expressions invoke the addition operators on objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3098
msgid "additiveExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3100
msgid "multiplicativeExpression (additiveOperator multiplicativeExpression)* |"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3103
msgid "super (additiveOperator multiplicativeExpression)+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3105
msgid "additiveOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3109
msgid "`+' | `-' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3113
msgid "An additive expression is either a multiplicative expression (10.24), or an invocation of an additive operator on either super or an expression e1, with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3116
msgid "An additive expression of the form e1 op e2 is equivalent to the method invocation e1.op(e2). An additive expression of the form super op e2 is equivalent to the method invocation super.op(e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3119
msgid "10.24 Multiplicative Expressions Multiplicative expressions invoke the multiplication operators on objects.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3121
msgid "Draft Dart Programming Language Specification Draft 61"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3123
msgid "multiplicativeExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3127
msgid "unaryExpression (multiplicativeOperator unaryExpression)* | super (multiplicativeOperator unaryExpression)+ ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3129
msgid "multiplicativeOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3135
msgid "`*' | `/' | `%' | `~/' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3138
msgid "A multiplicative expression is either a unary expression (10.25), or an invocation of a multiplicative operator on either super or an expression e1, with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3142
msgid "A multiplicative expression of the form e1 op e2 is equivalent to the method invocation e1.op(e2). A multiplicative expression of the form super op e2 is equivalent to the method invocation super.op(e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3145
msgid "10.25 Unary Expressions Unary expressions invoke unary operators on objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3147
msgid "unaryExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3154
msgid "prefixOperator unaryExpression | postfixExpression | unaryOperator super | `-' super | incrementOperator assignableExpression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3158
msgid "A unary expression is either a prefix expression (??), a postfix expression (10.26), an invocation of an increment operator on an expression or an invocation of a unary operator on either super or an expression e."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3161
msgid "The expression !e is equivalent to the expression e?false : true.  Evaluation of an expression of the form ++e is equivalent to e += 1. Evaluation of an expression of the form --e is equivalent to e -= 1."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3164
msgid "The expression -e is equivalent to the method invocation e.negate(). The expression -super is equivalent to the method invocation super.negate()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3168
msgid "An expression of the form op e is equivalent to the method invocation e.op().  An expression of the form op super is equivalent to the method invocation super.op().\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3172
msgid "Draft Dart Programming Language Specification Draft 62 10.26 Postfix Expressions Postfix expressions invoke the postfix operators on objects."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3174
msgid "postfixExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3178
msgid "assignableExpression postfixOperator | primary selector* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3180
msgid "postfixOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3183
msgid "incrementOperator ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3185
msgid "selector:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3189
msgid "assignableSelector | arguments ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3191
msgid "incrementOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3195
msgid "`++' | `--' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3198
msgid "A postfix expression is either a primary expression, a function, method or getter invocation, or an invocation of a postfix operator on an expression e."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3201
msgid "A postfix expression of the form v++, where v is an identifier, is equivalent to (){var r = v; v = r + 1; return r}()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3204
msgid "The above ensures that if v is a field, the getter gets called exactly once.  Likewise in the cases below."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3207
msgid "A postfix expression of the form C.v ++ is equivalent to (){var r = C.v; C.v = r + 1; return r}()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3210
msgid "A postfix expression of the form e1.v++ is equivalent to (x){var r = x.v; x.v = r + 1; return r}(e1)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3213
msgid "A postfix expression of the form e1[e2]++, is equivalent to (a, i){var r = a[i]; a[i] = r + 1; return r}(e1, e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3216
msgid "A postfix expression of the form v--, where v is an identifier, is equivalent to (){var r = v; v = r - 1; return r}()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3219
msgid "A postfix expression of the form C.v-- is equivalent to (){var r = C.v; C.v = r - 1; return r}()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3222
msgid "A postfix expression of the form e1.v-- is equivalent to (x){var r = x.v; x.v = r - 1; return r}(e1)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3225
msgid "A postfix expression of the form e1[e2]--, is equivalent to (a, i){var r = a[i]; a[i] = r - 1; return r}(e1, e2).\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3230
msgid "Draft Dart Programming Language Specification Draft 63 10.27 Assignable Expressions Assignable expressions are expressions that can appear on the left hand side of an assignment."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3235
msgid "Of course, if they always appeared as the left hand side, one would have no need for their value, and the rules for evaluating them would be unnecessary.  However, assignable expressions can be subexpressions of other expressions and therefore must be evaluated."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3237
msgid "assignableExpression:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3242
msgid "primary (arguments* assignableSelector)+ | super assignableSelector | identifier ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3244
msgid "assignableSelector:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3248
msgid "`[' expression `]' | `.' identifier ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3250
msgid "An assignable expression is either:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3252
msgid "An identifier."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3254
msgid "An invocation of a method, getter (7.2) or list access operator on an"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3256
msgid "expression e."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3259
#, no-wrap
msgid ""
"* An invocation of a getter or list access operator on super.\n"
"An assignable expression of the form id is evaluated as an identifier expression (10.28).\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3262
msgid "An assignable expression of the form e.id(a1, . . . , an) is evaluated as a method invocation (10.14)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3265
msgid "An assignable expression of the form e.id is evaluated as a getter invocation (10.15)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3267
msgid "An assignable expression of the form e1[e2] is evaluated as a method invocation of the operator method [] on e1 with argument e2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3269
msgid "An assignable expression of the form super.id is evaluated as a getter invocation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3272
msgid "An assignable expression of the form super[e2] is equivalent to the method invocation super.[](e2)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3276
msgid "10.28 Identifier Reference An identifier expression consists of a single identifier; it provides access to an object via an unqualified name.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3278
msgid "Draft Dart Programming Language Specification Draft 64"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3280
msgid "identifier:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3284
msgid "IDENTIFIER | BUILT IN IDENTIFIER ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3286
msgid "IDENTIFIER NO DOLLAR:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3289
msgid "IDENTIFIER START NO DOLLAR IDENTIFIER PART NO DOLLAR* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3291
msgid "IDENTIFIER:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3294
msgid "IDENTIFIER START IDENTIFIER PART* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3296
msgid "BUILT IN IDENTIFIER:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3314
msgid "abstract | assert | call | Dynamic | factory | get | implements | import | interface | library | negate | operator | set | source | static | typedef ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3316
msgid "IDENTIFIER START:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3320
msgid "IDENTIFIER START NO DOLLAR | '$' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3322
msgid "IDENTIFIER START NO DOLLAR:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3326
msgid "LETTER | ' ' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3328
msgid "IDENTIFIER PART NO DOLLAR:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3330
msgid "IDENTIFIER START NO DOLLAR |\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3332
msgid "Draft Dart Programming Language Specification Draft 65"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3337
msgid "IDENTIFIER PART:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3341
msgid "IDENTIFIER START | DIGIT ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3343
msgid "qualified:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3346
msgid "identifier (`.' identifier)? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3354
msgid "A built-in identifier is one of the identifiers produced by the production BU ILT IN IDEN T IF IER. It is a compile-time error if a built-in identifier is used as the declared name of a class, interface, type variable or type alias.  It is a compile-time error to use a built-in identifier other than Dynamic as a type annotation. It is a static warning if a built-in identifier is used as the name of a user-defined declaration, be it a variable, function, type or label, with the exception of user defined operators named negate or call."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3360
msgid "Built-in identifiers are identifiers that are used as keywords in Dart, but are not reserved words in Javascript. To minimize incompatibilities when porting Javascript code to Dart, we do not make these into reserved words. In other words, they are treated as reserved words when used as types. However, a builtin identifier may not be used to name a class or type. This eliminates many confusing situations without causing compatibility problems."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3366
msgid "Evaluation of an identifier expression e of the form id proceeds as follows: Let d be the innermost declaration in the enclosing lexical scope whose name is id. It is a compile-time error if d is a class, interface, type alias or type variable.  If no such declaration exists in the lexical scope, let d be the declaration of the inherited member named id if it exists."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3370
#, no-wrap
msgid ""
"* If d is a library variable, local variable, or formal parameter, then e evaluates to the current binding of id. This case also applies if d is a library or\n"
"local function declaration, as these are equivalent to function-valued variable\n"
"declarations.\n"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3372
msgid "If d is a static method, then e evaluates to the function defined by d."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3374
msgid "If d is the declaration of a static variable or static getter declared in class"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3376
msgid "C, then e is equivalent to the getter invocation (10.15) C.id."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3378
msgid "If d is the declaration of a top level getter, then e is equivalent to the"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3380
msgid "getter invocation id."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3382
msgid "Otherwise, e is equivalent to the property extraction this.id.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3386
msgid "Draft Dart Programming Language Specification Draft 66 10.29 Type Test The is-expression tests if an object is a member of a type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3388
msgid "isOperator:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3391
msgid "is `!' ? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3396
msgid "Evaluation of the is-expression e is T proceeds as follows: The expression e is evaluated to a value v. Then, if the interface induced by the class of v is a subtype of T , the is-expression evaluates to true. Otherwise it evaluates to false."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3399
msgid "It follows that e is Object is always true. This makes sense in a language where everything is an object."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3404
msgid "Also note that null is T is false unless T = Object or T = Null. Since the class Null is not exported by the core library, the latter will not occur in user code. The former is useless, as is anything of the form e is Object. Users should test for a null value directly rather than via type tests."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3409
msgid "The is-expression e is! T is equivalent to !(e is T ).  It is a compile-time error if T does not denote a type available in the current lexical scope. It is a compile-time error if T is a parameterized type of the form G < T1, . . . , Tn > and G is not a generic type with n type parameters."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3412
msgid "Note, that, in checked mode, it is a dynamic type error if a malformed typed is used in a type test as specified in 13.2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3414
msgid "The static type of an is-expression is bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3416
msgid "11 Statements"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3418
msgid "statements:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3421
msgid "statement* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3423
msgid "statement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3426
msgid "label* nonLabelledStatement ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3428
msgid "nonLabelledStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3436
msgid "block | initializedVariableDeclaration ';' | forStatement | whileStatement | doStatement | switchStatement | ifStatement |\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3438
msgid "Draft Dart Programming Language Specification Draft 67"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3448
msgid "tryStatement | breakStatement | continueStatement | returnStatement | throwStatement | expressionStatement | assertStatement | functionSignature functionBody ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3451
msgid "11.1 Blocks A block statement supports sequencing of code."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3454
msgid "Execution of a block statement {s1, . . . , sn} proceeds as follows: For i 2 1..n, si is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3457
msgid "11.2 Expression Statements An expression statement consists of an expression."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3459
msgid "expressionStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3461
msgid "expression? `;' |"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3467
msgid "Execution of an expression statement e; proceeds by evaluating e.  11.3 Variable Declaration A variable declaration statement declares a new local variable."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3473
msgid "A variable declaration statement T id; or T id = e; introduces a new variable id with static type T into the innermost enclosing scope. A variable declaration statement var id; or var id = e; introduces a new variable named id with static type Dynamic into the innermost enclosing scope. In all cases, iff the variable declaration is prefixed with the final modifier, the variable is marked as final."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3476
msgid "Executing a variable declaration statement T id = e; is equivalent to evaluating the assignment expression id = e, except that the assignment is considered legal even if the variable is final."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3480
msgid "However, it is still illegal to assign to a final variable from within its initializer.  A variable declaration statement of the form T id; is equivalent to T id = null;."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3484
msgid "This holds regardless of the type T . For example, int i; does not cause i to be initialized to zero. Instead, i is initialized to null, just as if we had written var i; or Object i; or Collection<String> i;.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3486
msgid "Draft Dart Programming Language Specification Draft 68"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3488
msgid "To do otherwise would undermine the optionally typed nature of Dart, causing type annotations to modify program behavior."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3491
msgid "11.4 If The if statement allows for conditional execution of statements."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3493
msgid "ifStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3496
msgid "if `(' expression `)' statement ( else statement)? ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3502
msgid "Execution of an if statement of the form if (b)s1 else s2 proceeds as follows: First, the expression b is evaluated to an object o. In checked mode, it is a dynamic type error if o is not of type bool. Otherwise, o is then subjected to boolean conversion (10.4.1), producing an object r. If r is true, then the statement s1 is executed, otherwise statement s2 is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3505
msgid "It is a static type warning if the type of the expression b may not be assigned to bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3508
msgid "An if statement of the form if (b)s1 is equivalent to the if statement if (b)s1 else {}."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3511
msgid "11.5 For The for statement supports iteration."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3513
msgid "forStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3516
msgid "for `(' forLoopParts `)' statement ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3518
msgid "forLoopParts:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3523
msgid "forInitializerStatement expression? `;' expressionList? | declaredIdentifier in expression | identifier in expression ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3525
msgid "forInitializerStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3529
msgid "initializedVariableDeclaration `;' | expression? `;' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3532
msgid "The for statement has two forms - the traditional for loop and the foreach statement.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3537
msgid "Draft Dart Programming Language Specification Draft 69 11.5.1 For Loop Execution of a for statement of the form for (var v = e0 ; c; e) s proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3540
msgid "If c is empty then let c0 be true otherwise let c0 be c.  First the variable declaration statement var v = e0 is executed. Then:"
msgstr ""

#. type: Bullet: '1. '
#: dartLangSpec.txt:3542
msgid "If this is the first iteration of the for loop, let v0 be v. Otherwise, let v0 be"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3544
msgid "the variable v00 created in the previous execution of step4 ."
msgstr ""

#. type: Bullet: '2. '
#: dartLangSpec.txt:3546
msgid "The expression [v0/v]c is evaluated and subjected to boolean conversion"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3549
msgid "(10.4). If the result is false, the for loop completes. Otherwise, execution continues at step 3."
msgstr ""

#. type: Bullet: '3. '
#: dartLangSpec.txt:3553
msgid "The statement [v0/v]s is executed."
msgstr ""

#. type: Bullet: '4. '
#: dartLangSpec.txt:3553
msgid "Let v00 be a fresh variable. v00 is bound to the value of v0."
msgstr ""

#. type: Bullet: '5. '
#: dartLangSpec.txt:3553
msgid "The expression [v00/v]e is evaluated, and the process recurses at step 1."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3559
msgid "The definition above is intended to prevent the common error where users create a closure inside a for loop, intending to close over the current binding of the loop variable, and find (usually after a painful process of debugging and learning) that all the created closures have captured the same value - the one current in the last iteration executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3564
msgid "Instead, each iteration has its own distinct variable. The first iteration uses the variable created by the initial declaration. The expression executed at the end of each iteration uses a fresh variable v00, bound on the value of the current iteration variable, and then modifies v00 as required for the next iteration."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3568
msgid "11.5.2 Foreach A for statement of the form for (f inalV arOrT ype id in e) s is equivalent to the the following code:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3571
msgid "var n0 = e.iterator(); while (n0.hasNext()) { finalV arOrT ype id = n0.next(); s } where n0 is an identifier that does not occur anywhere in the program."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3574
msgid "11.6 While The while statement supports conditional iteration, where the condition is evaluated prior to the loop."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3576
msgid "whileStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3579
msgid "while `(' expression `)' statement ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3581
msgid "Draft Dart Programming Language Specification Draft 70"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3588
msgid "Execution of a while statement of the form while (e) s; proceeds as follows: The expression e is evaluated to an object o. In checked mode, it is a dynamic type error if o is not of type bool. Otherwise, o is then subjected to boolean conversion (10.4.1), producing an object r. If r is true, then s is executed and then the while statement is re-executed recursively. If r is false, execution of the while statement is complete."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3590
#: dartLangSpec.txt:3607
msgid "It is a static type warning if the type of e may not be assigned to bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3593
msgid "11.7 Do The do statement supports conditional iteration, where the condition is evaluated after the loop."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3595
msgid "doStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3598
msgid "do statement while `(' expression `)' `;' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3605
msgid "Execution of a do statement of the form do s while (e); proceeds as follows: The statement s is executed. Then, the expression e is evaluated to an object o. In checked mode, it is a dynamic type error if o is not of type bool. Otherwise, o is then subjected to boolean conversion (10.4.1), producing an object r. If r is false, execution of the do statement is complete. If r is true, then the do statement is re-executed recursively."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3611
msgid "11.8 Switch The switch statement supports dispatching control among a large number of cases."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3613
msgid "switchStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3616
msgid "switch `(' expression `)' `{' switchCase* defaultCase? `}' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3618
msgid "switchCase:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3621
msgid "label? (case expression `:')+ statements ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3623
msgid "defaultCase:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3626
msgid "label? (case expression `:')* default `:' statements ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3629
msgid "Execution of a switch statement switch (e) { case e1 : s1 . . . case en : sn default sn+1 } proceeds as follows:\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3631
msgid "Draft Dart Programming Language Specification Draft 71"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3636
msgid "The statement var n = e; is evaluated, where n is a variable whose name is distinct from any other variable in the program. Next, the case clause case e1 : s1 is executed if it exists. If case e1 : s1 does not exist, then the default clause is executed by executing sn+1."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3639
msgid "Execution of a case clause case ek : sk of a switch statement switch (e) { case e1 : s1 . . . case en : sn default sn+1 } proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3642
msgid "The expression ek == n is evaluated to an object o which is then subjected to boolean conversion yielding a value v."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3647
msgid "If v is false the following case, case ek+1 : sk+1 is executed if it exists. If case ek+1 : sk+1 does not exist, then the default clause is executed by executing sn+1. If v is true, then let m be the smallest non-negative integer such that sk+m is non-blank; the statement sk+m is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3650
msgid "So, if sk is non-blank, m = 0. If the only non-blank statement is in the default clause, then m = n + 1 - k. For example"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3652
msgid "main() {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3654
msgid "foo(message, value) {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3657
msgid "print(message); return value;}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3659
msgid "switch (1) {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3662
msgid "case foo('case 1', 1): // s1 is blank case foo('case 2', 2): // s2 is non-blank; m = 1"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3664
msgid "print('hest');}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3671
msgid "} Should print: case 1 hest A switch statement switch (e) { case e1 : s1 . . . case en : sn } is equivalent to switch statement switch (e) { case e1 : s1 . . . case en : sn default }"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3674
msgid "It is a static warning if the type of e is may not be assigned to the type of ek for all k 2 1..n."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3677
msgid "11.9 Try The try statement supports the definition of exception handling code in a structured way."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3679
msgid "tryStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3682
msgid "try block (catchPart+ finallyPart? | finallyPart)  ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3684
msgid "catchPart:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3687
msgid "catch `(' declaredIdentifier (`, ' declaredIndentifier)? `)' block ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3689
msgid "Draft Dart Programming Language Specification Draft 72"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3691
msgid "finallyPart:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3694
msgid "finally block ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3697
msgid "A try statement consists of a block statement, followed by at least one of: 1. A set of catch clauses, each of which specifies one or two exception parameters and a block statement."
msgstr ""

#. type: Bullet: '2. '
#: dartLangSpec.txt:3699
msgid "A finally clause, which consists of a block statement."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3704
msgid "A catch clause of one of the forms catch (T1 p1, T2 p2) s or catch (T1 p1, p2) s matches an object o if o is null or if the type of o is a subtype of T1. It is a compile-time error if T1 does not denote a type available in the lexical scope of the catch clause."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3707
msgid "A catch clause of one of the forms catch (p1, T2 p2) s or catch (p1, p2) s always matches an object o."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3712
msgid "The definition below is an attempt to characterize exception handling without resorting to a normal/abrupt completion formulation. It has the advantage that one need not specify abrupt completion behavior for every compound statement.  On the other hand, it is new and different and needs more thought."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3715
msgid "A try statement try s1 catch1 . . . catchn finally sf defines an exception handler h that executes as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3722
msgid "The catch clauses are examined in order, starting with catch1, until either a catch clause that matches the current exception (11.14) is found, or the list of catch clauses has been exhausted. If a catch clause catchk is found, then pk1 is bound to the current exception, pk2 is bound to the current stack trace (11.14), and then catchk is executed. If no catch clause is found, the finally clause is executed. Then, execution resumes at the end of the try statement."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3726
msgid "A finally clause finally s defines an exception handler h that executes by executing the finally clause. Then, execution resumes at the end of the try statement."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3731
msgid "Execution of a catch clause catch (p1, p2) s of a try statement t proceeds as follows: The statement s is executed in the dynamic scope of the exception handler defined by the finally clause of t. Then, the current exception and current stack trace both become undefined."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3735
msgid "Execution of a finally clause finally s of a try statement proceeds as follows: The statement s is executed. Then, if the current exception is defined, control is transferred to the nearest dynamically enclosing exception handler."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3738
msgid "Execution of a try statement of the form try s1 catch1 . . . catchn finally sf ; proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3741
msgid "The statement s1 is executed in the dynamic scope of the exception handler defined by the try statement. Then, the finally clause is executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3744
msgid "Whether any of the catch clauses is executed depends on whether a matching exception has been raised by s1 (see the specification of the throw statement).\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3746
msgid "Draft Dart Programming Language Specification Draft 73"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3750
msgid "If s1 has raised an exception, it will transfer control to the try statements handler, which will examine the catch clauses in order for a match as specified above. If no matches are found, the handler will execute the finally clause."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3753
msgid "If a matching catch was found, it will execute first, and then the finally clause will be executed."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3757
msgid "If an exception is raised during execution of a catch clause, this will transfer control to the handler for the finally clause, causing the finally clause to execute in this case as well."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3761
msgid "If no exception was raised, the finally clause is also executed. Execution of the finally clause could also raise an exception, which will cause transfer of control to the next enclosing handler."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3764
msgid "11.10 Return The return statement returns a result to the caller of a function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3766
msgid "returnStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3769
msgid "return expression? ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3775
msgid "Executing a return statement return e; first causes evaluation of the expression e, producing an object o. Next, control is transferred to the caller of the current function activation, and the object o is provided to the caller as the result of the function call."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3778
msgid "It is a static type warning if the type of e may not be assigned to the declared return type of the immediately enclosing function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3781
msgid "It is a compile-time error if a return statement of the form return e; appears in a generative constructor (7.5.1)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3787
msgid "It is quite easy to forget to add the factory prefix for a constructor, accidentally converting a factory into a generative constructor. The static checker may detect a type mismatch in some, but not all, of these cases. The rule above helps catch such errors, which can otherwise be very hard to recognize. There is no real downside to it, as returning a value from a generative constructor is meaningless."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3790
msgid "Let f be the function immediately enclosing a return statement of the form return; It is a static warning if both of the following conditions hold:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:3792
msgid "f is not a generative constructor."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3796
#, no-wrap
msgid ""
"* The return type of f may not be assigned to void.\n"
"Hence, a static warning will not be issued if f has no declared return type, since\n"
"the return type would be Dynamic and Dynamic may be assigned to void. However, any function that declares a return type must return an expression explicitly.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3799
msgid "This helps catch situations where users forget to return a value in a return statement.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3801
msgid "Draft Dart Programming Language Specification Draft 74"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3805
msgid "A return statement of the form return; is executed by executing the statement return null; if it occurs inside a method, getter, setter or factory; otherwise, the return statement necessarily occurs inside a generative constructor, in which case it is executed by executing return this;."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3810
msgid "Despite the fact that return; is executed as if by a return e;, it is important to understand that it is not a static warning to include a statement of the form return; in a generative constructor. The rules relate only to the specific syntactic form return e;."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3815
msgid "The motivation for formulating return; in this way stems from the basic requirement that all function invocations indeed return a value. Function invocations are expressions, and we cannot rely on a mandatory typechecker to always prohibit use of void functions in expressions. Hence, a return statement must always return a value, even if no expression is specified."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3824
msgid "The question then becomes, what value should a return statement return when no return expression is given. In a generative constructor, it is obviously the object being constructed (this). A void function is not expected to participate in an expression, which is why it is marked void in the first place. Hence, this situation is a mistake which should be detected as soon as possible. The static rules help here, but if the code is executed, using null leads to fast failure, which is desirable in this case. The same rationale applies for function bodies that do not contain a return statement at all."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3829
msgid "11.11 Labels A label is an identifier followed by a colon. A labeled statement is a statement prefixed by a label L. A labeled case clause is a case clause within a switch statement (11.8) prefixed by a label L."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3832
msgid "The sole role of labels is to provide targets for the break (11.12) and continue (11.13) statements."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3834
msgid "label:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3837
msgid "identifier ':' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3841
msgid "The semantics of a labeled statement L : s are identical to those of the statement s. The namespace of labels is distinct from the one used for types, functions and variables."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3844
msgid "The scope of a label that labels a statement s is s. The scope of a label that labels a case clause of a switch statement s is s."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3848
msgid "Labels should be avoided by programmers at all costs. The motivation for including labels in the language is primarily making Dart a better target for code generation.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3853
msgid "Draft Dart Programming Language Specification Draft 75 11.12 Break The break statement consists of the reserved word break and an optional label (11.11)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3855
msgid "breakStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3858
msgid "break identifier? ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3867
msgid "Let sb be a break statement. If sb is of the form break L;, then let sE be the the innermost labeled statement with label L enclosing sb. If sb is of the form break;, then let sE be the the innermost do (11.7), for (11.5), switch (11.8) or while (11.6) statement enclosing sb. It is a compile-time error if no such statement sE exists within the innermost function in which sb occurs.  Furthermore, let s1, . . . , sn be those try statements that are both enclosed in sE and that enclose sb, and that have a finally clause. Lastly, let fj be the finally clause of sj, 1 <= j <= n. Executing sb first executes f1, . . . , fn in innermostclause-first order and then terminates sE."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3871
msgid "11.13 Continue The continue statement consists of the reserved word continue and an optional label (11.11)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3873
msgid "continueStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3876
msgid "continue identifier? ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3886
msgid "Let sc be a continue statement. If sc is of the form continue L;, then let sE be the the innermost labeled statement or case clause with label L enclosing sc. If sc is of the form continue; then let sE be the the innermost do (11.7), for (11.5) or while (11.6) statement enclosing sc. It is a compile-time error if no such statement or case clause sE exists within the innermost function in which sc occurs. Furthermore, let s1, . . . , sn be those try statements that are both enclosed in sE and that enclose sc, and that have a finally clause. Lastly, let fj be the finally clause of sj, 1 <= j <= n. Executing sc first executes f1, . . . , fn in innermost-clause-first order and then transfers control to sE."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3889
msgid "11.14 Throw The throw statement is used to raise or re-raise an exception."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3891
msgid "throwStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3894
msgid "throw expression? ';' ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3896
msgid "Draft Dart Programming Language Specification Draft 76"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3903
msgid "The current exception is the last unhandled exception thrown. The current stack trace is a record of all the function activations within the current isolate that had not completed execution at the point where the current exception was thrown. For each such function activation, the current stack trace includes the name of the function, the bindings of all its formal parameters, local variables and this, and the position at which the function was executing."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3907
msgid "The term position should not be interpreted as a line number, but rather as a precise position - the exact character index of the expression that raised in the exception."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3913
msgid "Execution of a throw statement of the form throw e; proceeds as follows: The expression e is evaluated yielding a value v. Then, control is transferred to the nearest dynamically enclosing exception handler (11.9), with the current exception set to v and the current stack trace set to the series of activations that led to execution of the current function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3916
msgid "There is no requirement that the expression e evaluate to a special kind of exception or error object."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3919
msgid "Execution of a statement of the form throw; proceeds as follows: Control is transferred to the nearest innermost enclosing exception handler (11.9)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3923
msgid "No change is made to the current stack trace or the current exception.  It is a compile-time error if a statement of the form throw; is not enclosed within a catch clause."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3927
msgid "11.15 Assert An assert statement is used to disrupt normal execution if a given boolean condition does not hold."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3929
msgid "assertStatement:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3932
msgid "assert '(' conditionalExpression ')' ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3935
msgid "The assert statement has no effect in production mode. In checked mode, execution of an assert statement assert(e); proceeds as follows:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3943
msgid "The conditional expression e is evaluated to an object o. If the class of o is a subtype of Function then let r be the result of invoking o with no arguments.  Otherwise, let r be o. It is a dynamic type error if o is not of type bool or of type Function, or if r is not of type bool. If r is false, we say that the assertion failed. If r is true, we say that the assertion succeeded. If the assertion succeeded, execution of the assert statement is complete. If the assertion failed, an AssertionError is thrown."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3946
msgid "It is a static type warning if the type of e may not be assigned to either bool or () ! bool."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3950
msgid "Why is this a statement, not a built in function call? Because it is handled magically so it has no effect and no overhead in production mode. Also, in the absence of final methods. one could not prevent it being overridden (though there\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3954
msgid "Draft Dart Programming Language Specification Draft 77 is no real harm in that). Overall, perhaps it could be defined as a function, and the overhead issue could be viewed as an optimization."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3957
msgid "If a lexically visible declaration named assert is in scope, an assert statement assert e; is interpreted as an expression statement (assert(e)); ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3964
msgid "Since assert is a built-in identifier, one might define a function or method with this name. It is impossible to distinguish as assert statement from a method invocation in such a situation. One could choose to always interpret such code as an assert statement. Or we could choose to give priority to any lexically visible user defined function. The former can cause rather puzzling situations, e.g.,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3966
msgid "assert(bool b)print('My Personal Assertion $b');"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3968
msgid "assert puzzler() {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3973
msgid "(assert(true)); // prints true assert(true); // would do nothing (assert(false)); // prints false assert(false); // would throw if asserts enabled, or do nothing otherwise}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3977
msgid "therefore, we opt for the second option. Alternately, one could insist that assert be a reserved word, which may have an undesirable effect with respect to compatibility of Javascript code ported to Dart."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3982
msgid "12 Libraries and Scripts A library consists of (a possibly empty) set of imports, and a set of top level declarations. A top level declaration is either a class (7), an interface (8), a type declaration, a function (6) or a variable declaration (5)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3984
msgid "topLevelDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3989
msgid "classDefinition | interfaceDefinition | functionTypeAlias | functionSignature functionBody |"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3991
msgid "returnType? getOrSet identifier formalParameterList functionBody |"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3995
msgid "final type? staticFinalDeclarationList ';' | variableDeclaration ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:3997
msgid "getOrSet:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4001
msgid "get | set ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4003
msgid "libraryDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4005
msgid "scriptTag? libraryName import* include* resource* topLevelDef\fDraft Dart Programming Language Specification Draft 78"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4007
msgid "inition*"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4011
msgid "scriptTag:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4014
msgid "`#!' (~NEWLINE)* NEWLINE ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4016
msgid "libraryName:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4019
msgid "`#' `library' `(' stringLiteral `)' `;' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4024
msgid "A library may optionally begin with a script tag, which can be used to identify the interpreter of the script to whatever computing environment the script is embedded in. A script tag begins with the characters #! and ends at the end of the line. Any characters after #! are ignored by the Dart implementation."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4029
msgid "Libraries are units of privacy. A private declaration declared within a library L can only be accessed by code within L. Any attempt to access a private member declaration from outside L will cause a method, getter or setter lookup failure."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4032
msgid "Since top level privates are not imported, using them is a compile-time error and not an issue here."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4035
msgid "The scope of a library L consists of the names introduced by all top level declarations declared in L, and the names added by L's imports (12.1)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4038
msgid "Libraries may include extralinguistic resources (e.g., audio, video or graphics files)"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4040
msgid "resource:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4043
msgid "`#' `resource' `(' stringLiteral `)' `;' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4046
msgid "12.1 Imports An import specifies a library to be used in the scope of another library."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4048
msgid "libraryImport:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4052
msgid "`#' `import' `(' stringLiteral (`, ' `prefix: ' stringLiteral)? `) `;' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4056
msgid "An import specifies a URI where the declaration of the imported library is to be found. The effect of an import of library B with prefix P within the declaration of library A is:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4058
msgid "If P is the empty string, each non-private top level declaration d of B is"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4060
msgid "added to the scope of A.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4062
msgid "Draft Dart Programming Language Specification Draft 79"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4064
msgid "Otherwise, each non-private top level declaration d of B is added to the"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4066
msgid "scope of A under the name P.d, as is the name P ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4069
msgid "Imports assume a global namespace of libraries (at least per isolate). They also assume the library is in control, rather than the other way around."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4072
msgid "It is a compile-time error if a name N is introduced into the library scope of a library A, and either:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4074
msgid "N is declared by A, OR"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4078
#, no-wrap
msgid ""
"* Another import introduces N into the scope of A.\n"
"This implies that it is a load-time error for a library to import itself, as the names\n"
"of its members will be duplicated.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4082
msgid "The current library is the library currently being compiled.  Compiling an import directive of the form #import(s1, prefix: s2); proceeds as follows:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4084
msgid "If the contents of the URI that is value of s1 have not yet been compiled"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4088
msgid "in the current isolate then they are compiled to yield a library B. It is a compile-time error if s1 does not denote a URI that contains the source code for a Dart library."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4090
msgid "Otherwise, the contents of URI denoted by s1 have been compiled into a"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4092
msgid "library B within the current library."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4094
msgid "Then, the library B is imported into the current library with prefix p,"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4096
msgid "where p is the value of s2."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4098
msgid "Compiling an include directive of the form #import(s) is equivalent to compiling the directive #import(s, prefix: \");."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4101
msgid "It is a compile-time error to import two or more libraries that define the same name."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4104
msgid "It is a compile-time error if either s1 or s2 is not a compile-time constant.  It is a compile-time error if the value of s2 is not a valid identifier."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4108
msgid "12.2 Includes An include directive specifies a URI where a Dart compilation unit that should be incorporated into the current library may be found."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4110
msgid "include:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4113
msgid "'#' 'source' '(' stringLiteral ')' ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4115
msgid "compilationUnit:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4118
msgid "topLevelDefinition* EOF ;\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4120
msgid "Draft Dart Programming Language Specification Draft 80"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4126
msgid "A compilation unit is a sequence of top level declarations.  Compiling an include directive of the form #source(s); causes the Dart system to attempt to compile the contents of the URI that is the value of s. The top level declarations at that URI are then compiled by the Dart compiler in the scope of the current library. It is a compile-time error if the contents of the URI are not a valid compilation unit."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4128
msgid "It is a compile-time error if s is not a compile-time constant."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4131
msgid "12.3 Scripts A script is a library with a top level function main()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4133
msgid "scriptDefinition:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4135
msgid "scriptTag? libraryName? import* include* resource* topLevelDefinition*"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4142
msgid "A script S may be executed as follows: First, S is compiled as a library as specified above. Then, the top level function main() that is in scope in S is invoked with no arguments. It is a run time error if S does not declare or import a top level function main()."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4147
msgid "The names of scripts are optional, in the interests of interactive, informal use. However, any script of long term value should be given a name as a matter of good practice. Named scripts are composable: they can be used as libraries by other scripts and libraries."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4150
msgid "13 Types Dart supports optional typing based on interface types."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4156
msgid "The type system is unsound, due to the covariance of generic types. This is a deliberate choice (and undoubtedly controversial). Experience has shown that sound type rules for generics fly in the face of programmer intuition. It is easy for tools to provide a sound type analysis if they choose, which may be useful for tasks like refactoring."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4161
msgid "13.1 Static Types Static type annotations are used in variable declarations (5) (including formal parameters (6.2)) and in the return types of functions (6). Static type annotations are used during static checking and when running programs in checked mode. They have no effect whatsoever in production mode."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4163
msgid "type:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4165
msgid "qualified typeArguments?\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4167
msgid "Draft Dart Programming Language Specification Draft 81"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4170
msgid "; typeArguments:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4173
msgid "'<' typeList '>' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4175
msgid "typeList:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4178
msgid "type (', ' type)* ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4181
msgid "A Dart implementation must provide a static checker that detects and reports exactly those situations this specification identifies as static warnings.  However:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4183
msgid "Running the static checker on a program P is not required for compiling"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4185
msgid "and running P ."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4187
msgid "Running the static checker on a program P must not prevent successful"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4190
msgid "compilation of P nor may it prevent the execution of P , regardless of whether any static warnings occur."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4195
msgid "Nothing precludes additional tools that implement alternative static analyses (e.g., interpreting the existing type annotations in a sound manner such as either non-variant generics, or inferring declaration based variance from the actual declarations). However, using these tools does not preclude successful compilation and execution of Dart code."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4200
msgid "13.2 Dynamic Type System A Dart implementation must support execution in both production mode and checked mode. Those dynamic checks specified as occurring specifically in checked mode must be performed iff the code is executed in checked mode."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4202
msgid "A type T is malformed iff:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4204
msgid "T has the form id, and id does not denote a type available in the enclosing"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4206
msgid "lexical scope."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4208
msgid "T is a parameterized type of the form G < S1, . . . , Sn >, and and any of"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4210
msgid "the following conditions hold:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4214
msgid "- Either G or Si, i 2 1..n are malformed.  - G is not a generic type with n type parameters.  - Let Ti be the type parameters of G (if any) and let Bi be the bound of"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4217
msgid "Ti, i 2 1..n, and Si is not a subtype of [S1, . . . , Sn/T1, . . . , Tn]Bi, i 2 1..n.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4219
msgid "Draft Dart Programming Language Specification Draft 82"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4223
msgid "In checked mode, it is a dynamic type error if a malformed type is used in a subtype test. In production mode, an undeclared type is treated as an instance of type Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4228
msgid "Consider the following program typedef F(bool x); f(foo x) => x; main() {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4230
msgid "if (f is F) {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4232
#: dartLangSpec.txt:4252
msgid "print(\"yoyoma\");}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4239
msgid "} The type of the formal parameter of f is foo, which is undeclared in the lexical scope. This will lead to a static type warning. Running the program in production mode will print yoyoma. In checked mode, however, the program will fail when executing the type test on the first line of main(). A similar situation would arise if we wrote"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4242
#: dartLangSpec.txt:4250
msgid "f(foo x) => x; main() {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4244
msgid "print(f(\"yoyoma\"));}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4247
msgid "but the reason would be slightly different - the implicit type test triggered by passing \"yoyoma00 to f would fail. In contrast, the program"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4255
msgid "runs without incident in both production mode and checked mode (though it too gives rise to a static warning)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4260
msgid "Note that subtype tests may occur implicitly in checked mode, as in var i; i j; // a variable j of type i (supposedly)  main() {"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4262
msgid "j = new Object(); // fails in checked mode}"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4269
msgid "Since i is not a type, a static warning will be issue at the declaration of j.  However, the program can be executed in production mode without incident. In checked mode, the assignment to j implicitly introduces a subtype test that checks whether the the type of the newly allocated object, Object, is a subtype of the malformed type i, which will cause a run-time error. However, no runtime error would occur if j was not used."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4275
msgid "One could have chosen to treat malformed types in checked mode as type Dynamic, as is done in production mode. After all, a static warning has already been given. That is a legitimate design option, and it is ultimately a judgement call as to whether checked mode should be more or less aggressive in dealing with such a situation.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4277
msgid "Draft Dart Programming Language Specification Draft 83"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4281
msgid "For now, we have opted to treat an undefined type as an error type that has no subtypes or supertypes, and which causes a runtime error when tested against any other type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4285
msgid "13.3 Type Declarations 13.3.1 Typedef A type alias declares a name for a type expression."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4287
msgid "functionTypeAlias:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4290
msgid "typedef functionPrefix typeParameters? formalParameterList ';' ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4292
msgid "functionPrefix:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4295
msgid "returnType? identifier ;"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4301
msgid "The effect of a type alias of the form typedef T id(T1 p1, . . . , Tn pn, [Tn+1 pn+1, . . . , Tn+k pn+k]) declared in a library L is is to introduce the name id into the scope of L, bound to the function type (T1, . . . , Tn, [Tn+1 pn+1, . . . , Tn+k pn+k]) ! T . If no return type is specified, it is taken to be Dynamic. Likewise, if a type annotation is omitted on a formal parameter, it is taken to be Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4304
msgid "Currently, type aliases are restricted to function types. It is a compile-time error if any default values are specified in the signature of a function type alias."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4307
msgid "13.4 Interface Types An interface I is a direct supertype of an interface J iff:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4309
msgid "If I is Object, and J has no extends clause"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4313
#, no-wrap
msgid ""
"* if I is listed in the extends clause of J.\n"
"A type T is more specific than a type S, written T << S, if one of the\n"
"following conditions is met:\n"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4315
msgid "T is S."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4317
msgid "T is ?."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4319
msgid "S is Dynamic."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4321
msgid "S is a direct supertype of T ."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4323
msgid "T is a type variable and S is the upper bound of T .\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4325
msgid "Draft Dart Programming Language Specification Draft 84"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4327
msgid "T is of the form I < T1, . . . , Tn > and S is of the form I < S1, . . . , Sn >"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4329
msgid "and: Ti << Si, 1 <= i <= n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4333
#, no-wrap
msgid ""
"* T << U and U << S.\n"
"<< is a partial order on types. T is a subtype of S, written T <: S, iff\n"
"[?/Dynamic]T << S.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4340
msgid "Note that <: is not a partial order on types, it is only binary relation on types. This is because <: is not transitive. If it was, the subtype rule would have a cycle. For example: List <: List < String > and List < int ><: List, but List < int > is not a subtype of List < String >. Although <: is not a partial order on types, it does contain a partial order, namely <<. This means that, barring raw types, intuition about classical subtype rules does apply."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4345
msgid "S is a supertype of T , written S :> T , iff T is a subtype of S.  The supertypes of an interface are its direct supertypes and their supertypes.  A type T may be assigned to a type S, written T () S, iff either T <: S or S <: T ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4350
msgid "This rule may surprise readers accustomed to conventional typechecking. The intent of the () relation is not to ensure that an assignment is correct. Instead, it aims to only flag assignments that are almost certain to be erroneous, without precluding assignments that may work."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4354
msgid "For example, assigning a value of static type Object to a variable with static type String, while not guaranteed to be correct, might be fine if the runtime value happens to be a string."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4359
msgid "13.5 Function Types A function type (T1, . . . Tn, [Tx1 x1, . . . , Txk xk]) ! T is a subtype of the function type (S1, . . . , Sn, [Sy1y1, . . . , Symym]) ! S, if all of the following conditions are met:"
msgstr ""

#. type: Bullet: '1. '
#: dartLangSpec.txt:4361
msgid "Either"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4363
msgid "S is void, Or*"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4365
msgid "T () S."
msgstr ""

#. type: Bullet: '2. '
#: dartLangSpec.txt:4368
msgid "8i 2 1..n, Ti () Si."
msgstr ""

#. type: Bullet: '3. '
#: dartLangSpec.txt:4368
msgid "k >= m and xi = yi, i 2 1..m. It is necessary, but not sufficient, that the"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4372
msgid "optional arguments of the subtype be a subset of those of the supertype. We cannot treat them as just sets, because optional arguments can be invoked positionally, so the order matters."
msgstr ""

#. type: Bullet: '4. '
#: dartLangSpec.txt:4374
msgid "For all y 2 {y1, . . . , ym}Sy () Ty"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4378
msgid "We write (T1, . . . , Tn) ! T as a shorthand for the type (T1, . . . , Tn, []) ! T .  All functions implement the interface Function, so all function types are a subtype of Function.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4380
msgid "Draft Dart Programming Language Specification Draft 85"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4385
msgid "If an interface type I includes the special operator call, and the type of call is the function type F , then I is considered to be a subtype of F . All functions implement the interface Function. However not all function types are a subtype of Function."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4388
msgid "13.6 Type Dynamic The type Dynamic denotes the unknown type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4392
msgid "If no static type annotation has been provided the type system assumes the declaration has the unknown type. If a generic type is used but the corresponding type arguments are not provided, then the missing type arguments default to the unknown type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4395
msgid "This means that given a generic declaration G < T1, . . . , Tn >, the type G is equivalent to G < Dynamic, . . . , Dynamic >."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4399
msgid "Type Dynamic has methods for every possible identifier and arity, with every possible combination of named parameters. These methods all have Dynamic as their return type, and their formal parameters all have type Dynamic. Type Dynamic has properties for every possible identifier. These properties all have type Dynamic."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4403
msgid "From a usability perspective, we want to ensure that the checker does not issue errors everywhere an unknown type is used. The definitions above ensure that no secondary errors are reported when accessing an unknown type."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4408
msgid "The current rules say that missing type arguments are treated as if they were the type Dynamic. An alternative is to consider them as meaning Object. This would lead to earlier error detection in checked mode, and more aggressive errors during static typechecking. For example:"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4415
msgid "(1) typedAPI(G<String>g){...} (2) typedAPI(new G()); Under the alternative rules, (2) would cause a runtime error in checked mode. This seems desirable from the perspective of error localization. However, when a dynamic error is raised at (2), the only way to keep running is rewriting (2) into"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4420
msgid "(3) typedAPI(new G<String>()); This forces users to write type information in their client code just because they are calling a typed API. We do not want to impose this on Dart programmers, some of which may be blissfully unaware of types in general, and genericity in particular."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4428
msgid "What of static checking? Surely we would want to flag (2) when users have explicitly asked for static typechecking? Yes, but the reality is that the Dart static checker is likely to be running in the background by default. Engineering teams typically desire a clean build free of warnings and so the checker is designed to be extremely charitable. Other tools can interpret the type information more aggressively and warn about violations of conventional (and sound) static type discipline.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4433
msgid "Draft Dart Programming Language Specification Draft 86 13.7 Type Void The special type void may only be used as the return type of a function: it is a compile-time error to use void in any other context."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4437
msgid "For example, as a type argument, or as the type of a variable or parameter Void is not an interface type.  The only subtype relations that pertain to void are therefore:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4439
msgid "void <: void (by reflexivity)"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4441
msgid "? <: void (as bottom is a subtype of all types)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4447
#, no-wrap
msgid ""
"* void <: Dynamic (as Dynamic is a supertype of all types)\n"
"Hence, the static checker will issue warnings if one attempts to access a member\n"
"of the result of a void method invocation (even for members of null, such as ==).\n"
"Likewise, passing the result of a void method as a parameter or assigning it to a\n"
"variable will cause a warning unless the variable/formal; parameter has type dynamic.\n"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4452
msgid "On the other hand, it is possible to return the result of a void method from within a void method. One can also return null; or a value of type Dynamic.  Returning any other result will cause a type warning (or a dynamic type error in checked mode)."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4455
msgid "13.8 Parameterized Types A parameterized type is an invocation of a generic type declaration."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4460
msgid "Let G < A1, . . . , An > be a parameterized type.  It is a static type warning if G is not an accessible generic type declaration with n type parameters. It is a static type warning if Ai, i 2 1..n does not denote a type in the enclosing lexical scope."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4465
msgid "If S is the static type of a member m of G, then the static type of the member m of G < A1, . . . , An > is [A1, . . . , An/T1, . . . , Tn]S where T1, . . . , Tn are the formal type parameters of G. Let Bi, be the bounds of Ti, 1 <= i <= n. It is a static type warning if Ai is not a subtype of [A1, . . . , An/T1, . . . , Tn]Bi, i 2 1..n."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4468
msgid "13.8.1 Actual Type of Declaration A type T depends on a type variable U iff:"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4470
msgid "T is U ."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4472
msgid "T is a parameterized type, and one of the type arguments of T depends"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4474
msgid "on U ."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4477
msgid "Let T be the declared type of a declaration d, as it appears in the program source. The actual type of d is"
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4479
msgid "[A1, . . . , An/U1, . . . , Un]T if d depends on type variables U1, . . . , Un, and"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4481
msgid "Ai is the value of Ui, 1 <= i <= n."
msgstr ""

#. type: Bullet: '* '
#: dartLangSpec.txt:4483
msgid "T otherwise.\f"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4492
msgid "Draft Dart Programming Language Specification Draft 87 13.8.2 Least Upper Bounds Given two interfaces I and J, let SI be the set of superinterfaces of I, let SJ be the set of superinterfaces of J and let S = (I [ SI ) \" (J [ SJ ). Furthermore, we define Sn = {T |T 2 S ^ depth(T ) = n} for any finite n, and k = max(depth(T1), . . . , depth(Tm)), Ti 2 S, i 2 1..m, where depth(T ) is the number of steps in the shortest inheritance path from T to Object. Let q be the smallest number such that Sq has cardinality one. The least upper bound of I and J is the sole element of Sq."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4497
msgid "14 Reference 14.1 Lexical Rules Dart source text is represented as a sequence of Unicode code points normalized to Unicode Normalization Form C."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4502
msgid "14.1.1 Reserved Words break, case, catch, class, const, continue, default, do, else, extends, false, final, finally, for, if , in, is, new, null, return, super, switch, this, throw, true, try, var, void, while."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4504
msgid "LETTER:"
msgstr "LETTER:"

#. type: Plain text
#: dartLangSpec.txt:4508
msgid "`a' .. `z' | `A' ..`Z' ;"
msgstr "`a' .. `z' | `A' ..`Z' ;"

#. type: Plain text
#: dartLangSpec.txt:4510
msgid "DIGIT:"
msgstr "DIGIT:"

#. type: Plain text
#: dartLangSpec.txt:4513
msgid "`0' .. `9' ;"
msgstr "`0' .. `9' ;"

#. type: Plain text
#: dartLangSpec.txt:4515
msgid "WHITESPACE:"
msgstr "WHITESPACE:"

#. type: Plain text
#: dartLangSpec.txt:4518
msgid "(`\\t' | ` ' | NEWLINE)+ ;"
msgstr "(`\\t' | ` ' | NEWLINE)+ ;"

#. type: Plain text
#: dartLangSpec.txt:4521
msgid "14.1.2 Comments Comments are sections of program text that are used for documentation."
msgstr ""
"14.1.2 コメント \n"
"コメントとは、ドキュメンテーションのために使われるプログラムテキストの区分のことである。"

#. type: Plain text
#: dartLangSpec.txt:4523
msgid "SINGLE LINE COMMENT:"
msgstr "SINGLE LINE COMMENT:"

#. type: Plain text
#: dartLangSpec.txt:4526
msgid "`//' ~(NEWLINE)* (NEWLINE)? ;\f"
msgstr "`//' ~(NEWLINE)* (NEWLINE)? ;\f"

#. type: Plain text
#: dartLangSpec.txt:4528
msgid "Draft Dart Programming Language Specification Draft 88"
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4530
msgid "MULTI LINE COMMENT:"
msgstr "MULTI LINE COMMENT:"

#. type: Plain text
#: dartLangSpec.txt:4533
msgid "`/*' (MULTI LINE COMMENT | ~ `*/')* `*/' ;"
msgstr "`/*' (MULTI LINE COMMENT | ~ `*/')* `*/' ;"

#. type: Plain text
#: dartLangSpec.txt:4536
msgid "Dart supports both single-line and multi-line comments. A single line comment begins with the token //. Everything between // and the end of line must be ignored by the Dart compiler."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4540
msgid "A multi-line comment begins with the token /* and ends with the token */.  Everything between /* and */ must be ignored by the Dart compiler unless the comment is a documentation comment. Comments may nest."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4543
msgid "Documentation comments are multi-line comments that begin with the tokens /**. Inside a documentation comment, the Dart compiler ignores all text unless it is enclosed in brackets."
msgstr ""

#. type: Plain text
#: dartLangSpec.txt:4545
msgid "14.2 Operator Precedence Operator precedence is given implicitly by the grammar.\f"
msgstr ""

